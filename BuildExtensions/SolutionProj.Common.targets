<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
    This targets file is imported by a .slnproj to implement standard solution project build
    behavior. The standard slnproj functionality goes well beyond what a normal Visual Studio
    Solution does as it is designed and targeted to automated build scenarios. Rather than
    relying on the particular automated build system (Jenkins, VSO build tasks, TFS XAML build
    definitions, etc...) to do most of the work of a build the solution proj does the bulk of a
    build so that it is more easily re-hosted, and more importantly reproduced on a developer's
    machine for testing.

    All targets with a name beginning with '_' are internal targets subject to change over time.
    slnproj files should not reference or depend on them in anyway.
    -->
    <Import Project="$([MSBuild]::GetPathOfFileAbove(Directory.Build.targets))" Condition="exists($([MSBuild]::GetPathOfFileAbove(Directory.Build.targets)))" />

    <Target Name="PrepareForBuild" DependsOnTargets="$(PrepareForBuildDependsOn)" />

    <!-- Builds all of the various configuration options for the BuildProject items -->
    <Target Name="BuildContentBinaries">
        <!--
        This is a bit crude but functional, a more generlaized solution would
        retrieve all the project  references to form a DAG and ensure that any
        depenencies are built (with all platform/configs) before doing a pack.
        This would include performing the pack for any referenced projects that
        are packable BEFORE building anything that depends on the pack.
        -->
        <ItemGroup>
            <_NativeProject Include="@(BuildProject->WithMetadataValue('Native','true'))" />
            <_ManagedProjects Include="@(BuildProject->WithMetadataValue('Native','false'))" />
        </ItemGroup>

        <!-- Build the native projects before all else so that they can be packed and the resulting package consumed by later projects -->
        <CreateMultiConfigProjectList Projects="@(_NativeProject)">
            <Output ItemName="_NativeProjectWithConfiguration" TaskParameter="Result"/>
        </CreateMultiConfigProjectList>

        <MSBuild Projects="@(_NativeProjectWithConfiguration)"
                 Targets="Build"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>

        <MSBuild Projects="@(_NativeProject->WithMetadataValue('Pack','true'))"
                 Targets="Pack"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>

        <!-- Build the Managed projects before all else so that they can be packed and the resulting package consumed by later projects -->
        <CreateMultiConfigProjectList Projects="@(_ManagedProject)">
            <Output ItemName="_ManagedProjectWithConfiguration" TaskParameter="Result"/>
        </CreateMultiConfigProjectList>

        <MSBuild Projects="@(_ManagedProjectWithConfiguration)"
                 Targets="Build"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>

        <MSBuild Projects="@(_ManagedProject->WithMetadataValue('Pack','true'))"
                 Targets="Pack"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>
    </Target>

    <!--
    Creates core output folders that tasks require. Not all folders are explicitly created here
    as most of the tasks can create the folder if they don't exist. Some, like the nuget tasks,
    however, cannot.
    -->
    <Target Name="CreateOutputFolders">
        <MakeDir Condition="!EXISTS('$(BaseBuildOutputPath)')" Directories="$(BaseBuildOutputPath)" />
        <MakeDir Condition="!EXISTS('$(BaseBuildOutputPath)\tools')" Directories="$(BaseBuildOutputPath)\tools"/>
        <MakeDir Condition="!EXISTS('$(BaseOutputPath)')" Directories="$(BaseOutputPath)"/>
        <MakeDir Condition="!EXISTS('$(BaseSignedOutputPath)')" Directories="$(BaseSignedOutputPath)"/>
    </Target>

    <!-- Cleans the common build output folder -->
    <Target Name="CleanOutputFolders">
        <ItemGroup>
            <_FilesToClean Include="$(BaseBuildOutputPath)\**\*" />
        </ItemGroup>
        <ItemGroup>
            <_FoldersToClean Include="@(_FilesToClean->'%(RootDir)%(Directory)')"/>
        </ItemGroup>
        <Delete Files="@(_FilesToClean)" />
        <RemoveDir Directories="$(BaseBuildOutputPath)" />
    </Target>

    <!-- Download the nuget.exe if it isn't found-->
    <Target Name="_DownloadNugetExe" >
        <DownloadFile Condition="!EXISTS('$(NugetExePath)')"
                      SourceUrl="https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
                      DestinationPath="$(NugetExePath)"
                      />
    </Target>

    <!-- Create nuget packages for all NuSpec Items -->
    <Target Name="PackageContent" DependsOnTargets="EnsureBuildNumbers;_DownloadNugetExe" >
        <MakeDir Directories="$(BaseSignedOutputPath)Nuget\" Condition="!EXISTS('$(BaseSignedOutputPath)Nuget\')" />
        <Exec
            Condition="exists('%(NugetPackage.FullPath)')"
            Command='"$(NugetExePath)" pack %(NugetPackage.FullPath) -OutputDirectory $(PackageOutputPath) -Properties buildversion=$(FullBuildNumber);%(NugetPackage.NuSpecProperties) -NoPackageAnalysis' />
        <ItemGroup>
            <PackagesToSign Include="$(BaseSignedOutputPath)Nuget\%(NugetPackage.FileName).$(FullBuildNumber).nupkg" Condition="exists('$(BaseSignedOutputPath)Nuget\%(NugetPackage.FileName).$(FullBuildNumber).nupkg')"/>
        </ItemGroup>
    </Target>

    <!-- Restores nuget packages for projects listed in the NugetRestorePackage item list -->
    <Target Name="NugetRestore" DependsOnTargets="_DownloadNugetExe" >
        <Exec Condition="exists('%(NugetRestorePackage.FullPath)')"
              Command='"$(NugetExePath)" restore %(NugetRestorePackage.FullPath) -NonInteractive -PackagesDirectory %(NugetRestorePackage.PackagesDirectory)' />
    </Target>

    <!--
    For now this just generates a SHA256 hash for NUGET packages,
    once real signing is available this will handle signing any
    package formats that support signing.
    -->
    <Target Name="SignPackage">
        <!-- generate Sha256 hash so that builds can at least be verified as coming from the official build -->
        <GenerateSha256File Files="@(PackagesToSign)"/>
    </Target>

    <Target Name="Build" DependsOnTargets="$(BuildDependsOn)"/>
</Project>
