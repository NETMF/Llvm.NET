<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
    This targets file is imported by a .slnproj to implement standard solution project build
    behavior. The standard slnproj functionality goes well beyond what a normal Visual Studio
    Solution does as it is designed and targeted to automated build scenarios. Rather than
    relying on the particular automated build system (Jenkins, VSO build tasks, TFS XAML build
    definitions, etc...) to do most of the work of a build the solution proj does the bulk of a
    build so that it is more easily re-hosted, and more importantly reproduced on a developer's
    machine for testing.

    All targets with a name beginning with '_' are internal targets subject to change over time.
    slnproj files should not reference or depend on them in anyway.
    -->
    <Import Project="$([MSBuild]::GetPathOfFileAbove(Directory.Build.targets))" Condition="exists($([MSBuild]::GetPathOfFileAbove(Directory.Build.targets)))" />

    <Target Name="PrepareForBuild" DependsOnTargets="PrepareForBuildDependsOn" />

    <!-- Builds all of the various configuration options for the BuildProject items -->
    <Target Name="BuildContentBinaries">
        <!--
        This is  bit crude but functional, a more generlaized solution would
        retrieve all the project  references to form a DAG and ensure that any
        depenencies are uilt (with all platform/configs) before doing a pack.
        This would include performing the pack for any referenced projects that
        are packable BEFORE building anything that depends on the pack.
        -->
        <ItemGroup>
            <_NativeProject Include="@(BuildProject->WithMetadataValue('Native','true'))" />
            <_ManagedProjects Include="@(BuildProject->WithMetadataValue('Native','false'))" />
        </ItemGroup>

        <!-- Build the native projects before all else so that they can be packed and the resulting package consumed by later projects -->
        <CreateMultiConfigProjectList Projects="@(_NativeProject)">
            <Output ItemName="_NativeProjectWithConfiguration" TaskParameter="Result"/>
        </CreateMultiConfigProjectList>

        <MSBuild Projects="@(_NativeProjectWithConfiguration)"
                 Targets="Build"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>

        <MSBuild Projects="@(_NativeProject->WithMetadataValue('Pack','true'))"
                 Targets="Pack"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>

        <!-- Build the Managed projects before all else so that they can be packed and the resulting package consumed by later projects -->
        <CreateMultiConfigProjectList Projects="@(_ManagedProject)">
            <Output ItemName="_ManagedProjectWithConfiguration" TaskParameter="Result"/>
        </CreateMultiConfigProjectList>

        <MSBuild Projects="@(_ManagedProjectWithConfiguration)"
                 Targets="Build"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>

        <MSBuild Projects="@(_ManagedProject->WithMetadataValue('Pack','true'))"
                 Targets="Pack"
                 Properties="BuildMajor=$(BuildMajor);BuildMinor=$(BuildMinor);BuildNumber=$(BuildNumber);BuildRevision=$(BuildRevision)"
                 BuildInParallel="true"
                 >
        </MSBuild>

    </Target>

    <!-- Internal build target to Filter the BuildProject item list to a new list containing only release configurations -->
    <Target Name="_CreateReleaseProjectItems" DependsOnTargets="_CreateMultiConfigProjectList">
        <!-- Filter the project list to find the ones where Configuration==Release -->
        <FilterReleaseProjects Projects="@(_MultiConfigBuildProjects)">
            <Output ItemName="ReleaseProjects" TaskParameter="ReleaseProjects"/>
        </FilterReleaseProjects>
    </Target>

    <!--
    This target performs signing of binaries supporting signatures (Authenticode, StrongName, etc...)
    For the moment, there is no official signing key so this just generates SHA256 signatures and copies
    the files to the signed location. However, when signing is available, only this target needs to change
    as everything is already set up to handle the signed binaries in a distinct location.
    -->
    <Target Name="SignContent" DependsOnTargets="_CreateReleaseProjectItems" Condition="'%(ReleaseProjects.SignOutput)'!=''">
        <Message Importance="high" Text="Copying Files to signed location... (Actual signing not yet supported)" />
        <!-- For now just copy the release binaries to "fake" signing until fully signed builds enabled -->
        <Copy DestinationFolder="$(BaseSignedOutputPath)%(ReleaseProjects.Platform)\%(ReleaseProjects.Configuration)\"
              SourceFiles="$(BaseOutputPath)%(ReleaseProjects.Platform)\%(ReleaseProjects.Configuration)\%(ReleaseProjects.SignOutput)"
              />
        <!-- generate Sha256 hash so that builds can at least be verified -->
        <GenerateSha256File Files="$(BaseSignedOutputPath)%(ReleaseProjects.Platform)\%(ReleaseProjects.Configuration)\%(ReleaseProjects.SignOutput)"/>
    </Target>

    <!--
    Creates core output folders that tasks require. Not all folders are explicitly created here
    as most of the tasks can create the folder if they don't exist. Some, like the nuget tasks,
    however, cannot.
    -->
    <Target Name="CreateOutputFolders">
        <MakeDir Condition="!EXISTS('$(BaseBuildOutputPath)')" Directories="$(BaseBuildOutputPath)" />
        <MakeDir Condition="!EXISTS('$(BaseBuildOutputPath)\tools')" Directories="$(BaseBuildOutputPath)\tools"/>
        <MakeDir Condition="!EXISTS('$(BaseOutputPath)')" Directories="$(BaseOutputPath)"/>
        <MakeDir Condition="!EXISTS('$(BaseSignedOutputPath)')" Directories="$(BaseSignedOutputPath)"/>
    </Target>

    <!-- Cleans the common build output folder -->
    <Target Name="CleanOutputFolders">
        <ItemGroup>
            <_FilesToClean Include="$(BaseBuildOutputPath)\**\*" />
        </ItemGroup>
        <ItemGroup>
            <_FoldersToClean Include="@(_FilesToClean->'%(RootDir)%(Directory)')"/>
        </ItemGroup>
        <Delete Files="@(_FilesToClean)" />
        <RemoveDir Directories="$(BaseBuildOutputPath)" />
    </Target>

    <!-- Download the nuget.exe if it isn't found-->
    <Target Name="_DownloadNugetExe" >
        <DownloadFile Condition="!EXISTS('$(NugetExePath)')"
                      SourceUrl="https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
                      DestinationPath="$(NugetExePath)"
                      />
    </Target>

    <!-- Create nuget packages for all NuSpec Items -->
    <Target Name="PackageContent" DependsOnTargets="EnsureBuildNumbers;_DownloadNugetExe" >
        <MakeDir Directories="$(BaseSignedOutputPath)Nuget\" Condition="!EXISTS('$(BaseSignedOutputPath)Nuget\')" />
        <Message Importance="high" Text="++Building Nuget Package..."/>
        <Exec Command='"$(NugetExePath)" pack %(NugetPackage.FullPath) -OutputDirectory $(PackageOutputPath) -Properties buildversion=$(FullBuildNumber);%(NugetPackage.NuSpecProperties) -NoPackageAnalysis' />
        <ItemGroup>
            <PackagesToSign Include="$(BaseSignedOutputPath)Nuget\%(NugetPackage.FileName).$(FullBuildNumber).nupkg"/>
        </ItemGroup>
    </Target>

    <!-- Restores nuget packages for projects listed in the NugetRestorePackage item list -->
    <Target Name="NugetRestore" DependsOnTargets="_DownloadNugetExe" >
        <Exec Condition="EXISTS('%(NugetRestorePackage.FullPath)')"
              Command='"$(NugetExePath)" restore %(NugetRestorePackage.FullPath) -NonInteractive -PackagesDirectory %(NugetRestorePackage.PackagesDirectory) -MSBuildVersion %(NugetRestorePackage.MSBuildVersion)' />
    </Target>

    <!--
    For now this just generates a SHA256 hash for NUGET packages,
    once real signing is available this will handle signing any
    package formats that support signing.
    -->
    <Target Name="SignPackage">
        <!-- generate Sha256 hash so that builds can at least be verified as coming from the official build -->
        <GenerateSha256File Files="@(PackagesToSign)"/>
    </Target>

    <Target Name="Build" DependsOnTargets="$(BuildDependsOn)"/>
</Project>
