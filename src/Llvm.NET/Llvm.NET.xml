<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Llvm.NET</name>
    </assembly>
    <members>
        <member name="M:Llvm.NET.ArgValidationExtensions.VerifyArgNotNull``1(``0,System.String)">
            <summary>Fluent style method for validating a function argument is not null</summary>
            <typeparam name="T">Type of the argument</typeparam>
            <param name="self">argument value to test for null</param>
            <param name="name">name of the argument to appear in the exception</param>
            <returns>
            <paramref name="self"/> unless it is null, in which case an <see cref="T:System.ArgumentNullException"/>
            is thrown.
            </returns>
            <remarks>
            This is useful for validating cases where a parameter must be used to compute
            an additional parameter to a base class constructor.
            </remarks>
        </member>
        <member name="T:Llvm.NET.Comdat">
            <summary>Comdat entry for a module</summary>
            <remarks>
            A COMDAT is a named kind pair to ensure that, within
            a given module there are no two named COMDATs with a
            different kinds. Ultimately, Comdat is 'owned' by the
            module, if the module is disposed the Comdats it owns
            are invalidated. Using a Comdat instance after the
            module is disposed results in an effective NOP.
            </remarks>
        </member>
        <member name="T:Llvm.NET.ContextValidator">
            <summary>Provides validation extensions to the <see cref="T:Llvm.NET.Context"/> class</summary>
            <remarks>
            These are done as extensions deliberately to allow for the possibility that the provided
            context may actually be <see langword="null"/>, which wouldn't be possible as member methods.
            </remarks>
        </member>
        <member name="M:Llvm.NET.ContextValidator.VerifyAsArg(Llvm.NET.Context,System.String,System.String)">
            <summary>Throw an <see cref="T:System.ArgumentException"/> if the <see cref="T:Llvm.NET.Context"/> is <see langword="null"/> or is disposed</summary>
            <param name="context"><see cref="T:Llvm.NET.Context"/>to test</param>
            <param name="name">Argument name</param>
            <param name="message">Error message for the exception</param>
        </member>
        <member name="M:Llvm.NET.ContextValidator.VerifyAsArg(Llvm.NET.Context,System.String)">
            <summary>Throw an <see cref="T:System.ArgumentException"/> if the <see cref="T:Llvm.NET.Context"/> is <see langword="null"/> or is disposed</summary>
            <param name="context"><see cref="T:Llvm.NET.Context"/>to test</param>
            <param name="name">Argument name</param>
        </member>
        <member name="M:Llvm.NET.ContextValidator.VerifyOperation(Llvm.NET.Context,System.String)">
            <summary>Throw an <see cref="T:System.InvalidOperationException"/> if the <see cref="T:Llvm.NET.Context"/> is <see langword="null"/> or is disposed</summary>
            <param name="context"><see cref="T:Llvm.NET.Context"/>to test</param>
            <param name="message">Error message for the exception</param>
        </member>
        <member name="M:Llvm.NET.ContextValidator.VerifyOperation(Llvm.NET.Context)">
            <summary>Throw an <see cref="T:System.InvalidOperationException"/> if the <see cref="T:Llvm.NET.Context"/> is <see langword="null"/> or is disposed</summary>
            <param name="context"><see cref="T:Llvm.NET.Context"/>to test</param>
        </member>
        <member name="M:Llvm.NET.ContextValidator.Verify(Llvm.NET.Context,System.String,System.String,System.Action{System.String,System.String})">
            <summary>Execute a given action if the <see cref="T:Llvm.NET.Context"/> is <see langword="null"/> or is disposed</summary>
            <param name="context"><see cref="T:Llvm.NET.Context"/>to test</param>
            <param name="name">Argument name or <see langword="null"/> if name is not needed by the supplied <paramref name="failAction"/></param>
            <param name="message">Error message for the <paramref name="failAction"/></param>
            <param name="failAction">Action to perform if the verification fails</param>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugArrayType">
            <summary>Provides debug information binding between an <see cref="T:Llvm.NET.Types.IArrayType"/>and a <see cref="T:Llvm.NET.DebugInfo.DICompositeType"/></summary>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugArrayType.#ctor(Llvm.NET.Types.IArrayType,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.NativeModule,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DebugArrayType"/></summary>
            <param name="llvmType">Underlying LLVM array type to bind debug info to</param>
            <param name="elementType">Array element type with debug information</param>
            <param name="module">module to use for creating debug information</param>
            <param name="count">Number of elements in the array</param>
            <param name="lowerBound">Lower bound of the array [default = 0]</param>
            <param name="alignment">Alignment for the type</param>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugArrayType.#ctor(Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.NativeModule,System.UInt32,System.UInt32)">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugArrayType"/></summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="module"><see cref="T:Llvm.NET.NativeModule"/> to use for the context of the debug information</param>
            <param name="count">Number of elements in the array</param>
            <param name="lowerBound"><see cref="P:Llvm.NET.DebugInfo.DebugArrayType.LowerBound"/> value for the array indices [Default: 0]</param>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugArrayType.#ctor(Llvm.NET.Types.IArrayType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIType,System.UInt32,System.UInt32)">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugArrayType"/></summary>
            <param name="llvmType">Native LLVM type for the elements</param>
            <param name="module"><see cref="T:Llvm.NET.NativeModule"/> to use for the context of the debug information</param>
            <param name="elementType">Debug type of the array elements</param>
            <param name="count">Number of elements in the array</param>
            <param name="lowerBound"><see cref="P:Llvm.NET.DebugInfo.DebugArrayType.LowerBound"/> value for the array indices [Default: 0]</param>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugArrayType.DebugElementType">
            <summary>Full <see cref="T:Llvm.NET.DebugInfo.IDebugType`2"/> type for the elements</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugArrayType.ElementType">
            <inheritdoc/>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugArrayType.Length">
            <inheritdoc/>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugArrayType.LowerBound">
            <summary>Lower bound of the array, usually but not always zero</summary>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugArrayType.ResolveTemporary(Llvm.NET.DataLayout,Llvm.NET.DebugInfo.DebugInfoBuilder)">
            <summary>Resolves a temporary metadata node for the array if full size information wasn't available at creation time</summary>
            <param name="layout">Type layout information</param>
            <param name="diBuilder">Debug information builder for creating the new debug information</param>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugMemberInfo">
            <summary>Describes a member/field of a type for creating debug information</summary>
            <remarks>
            <para>This class is used with <see cref="T:Llvm.NET.DebugInfo.DebugStructType"/> to provide debug information for a type.</para>
            <para>In order to support explicit layout structures the members relating to layout are all <see cref="T:System.Nullable`1"/>.
            When they are null then modules <see cref="P:Llvm.NET.NativeModule.Layout"/> target specific layout information is used to determine
            layout details. Setting the layout members of this class to non-null will override that behavior to define explicit
            layout details.</para>
            </remarks>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.Index">
            <summary>LLVM structure element index this descriptor describes</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.Name">
            <summary>Name of the field</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.File">
            <summary>File the field is declared in</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.Line">
            <summary>Line the field is declared on</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.DebugInfoFlags">
            <summary>flags for the field declaration</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.DebugType">
            <summary>Debug type information for this field</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberInfo.ExplicitLayout">
            <summary>Provides explicit layout information for this member</summary>
            <remarks>If this is null then <see cref="M:Llvm.NET.DebugInfo.DebugStructType.SetBody(System.Boolean,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DebugMemberInfo})"/>
            will default to using <see cref="P:Llvm.NET.NativeModule.Layout"/> to determine the size using the module's target specific layout.
            <note type="note">
            If this property is provided (e.g. is not <see langword="null"/>) for any member of a type, then
            it must be set for all members. In other words explicit layout must be defined for all members
            or none. Furthermore, for types using explicit layout, the type containing this member must
            include the "packed" modifier.
            </note>
            </remarks>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugMemberLayout">
            <summary>DebugMemberLayout is used to define custom layout information for structure members</summary>
            <remarks>
            Ordinarily layout information is handle automatically in
            <see cref="M:Llvm.NET.DebugInfo.DebugStructType.SetBody(System.Boolean,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DebugMemberInfo})"/>
            however in cases where explicitly controlled (or "packed") layout is required, instances of DebugMemberLayout are
            used to provide the information necessary to generate a proper type and debug information.
            </remarks>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugMemberLayout.#ctor(System.UInt64,System.UInt32,System.UInt64)">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugMemberLayout"/></summary>
            <param name="bitSize">Size of the member in bits</param>
            <param name="bitAlignment">Alignment of the member in bits</param>
            <param name="bitOffset">Offset of the member in bits</param>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberLayout.BitSize">
            <summary>Bit size for the field</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberLayout.BitAlignment">
            <summary>Bit alignment for the field</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugMemberLayout.BitOffset">
            <summary>Bit offset for the field in it's containing type</summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugPointerType">
            <summary>Binding between a <see cref="T:Llvm.NET.DebugInfo.DIDerivedType"/> and an <see cref="T:Llvm.NET.Types.IPointerType"/></summary>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.NativeModule,System.UInt32,System.String,System.UInt32)">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType"/></summary>
            <param name="debugElementType">Debug type of the pointee</param>
            <param name="module"><see cref="T:Llvm.NET.NativeModule"/> used for creating the pointer type and debug information</param>
            <param name="addressSpace">Target address space for the pointer [Default: 0]</param>
            <param name="name">Name of the type [Default: null]</param>
            <param name="alignment">Alignment on pointer</param>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.Types.ITypeRef,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIType,System.UInt32,System.String,System.UInt32)">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType"/></summary>
            <param name="llvmElementType">Native type of the pointee</param>
            <param name="module"><see cref="T:Llvm.NET.NativeModule"/> used for creating the pointer type and debug information</param>
            <param name="elementType">Debug type of the pointee</param>
            <param name="addressSpace">Target address space for the pointer [Default: 0]</param>
            <param name="name">Name of the type [Default: null]</param>
            <param name="alignment">Alignment of pointer</param>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.Types.IPointerType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DIType,System.String,System.UInt32)">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType"/></summary>
            <param name="llvmPtrType">Native type of the pointer</param>
            <param name="module"><see cref="T:Llvm.NET.NativeModule"/> used for creating the pointer type and debug information</param>
            <param name="elementType">Debug type of the pointee</param>
            <param name="name">Name of the type [Default: null]</param>
            <param name="alignment">Alignment for pointer type</param>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugPointerType.#ctor(Llvm.NET.Types.IPointerType,Llvm.NET.DebugInfo.DIDerivedType)">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugPointerType"/></summary>
            <param name="llvmPtrType">Native type of the pointer</param>
            <param name="debugType">Debug type for the pointer</param>
            <remarks>
            This constructor is typically used when building typedefs to a basic type
            to provide namespace scoping for the typedef for languages that support
            such a concept. This is needed because basic types don't have any namespace
            information in the LLVM Debug information (they are implicitly in the global
            namespace)
            </remarks>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugPointerType.AddressSpace">
            <inheritdoc/>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugPointerType.ElementType">
            <inheritdoc/>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugUnionType">
            <summary>Debug representation of a union type</summary>
            <remarks>The underlying native LLVM type is a structure with a single member</remarks>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DINodeArray">
            <summary>Array of <see cref="T:Llvm.NET.DebugInfo.DINode"/> debug information nodes for use with <see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder"/> methods</summary>
            <seealso cref="M:Llvm.NET.DebugInfo.DebugInfoBuilder.GetOrCreateArray(System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.DINode})"/>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIBasicType">
            <summary>Debug information for a basic type</summary>
            <seealso cref="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateBasicType(System.String,System.UInt64,Llvm.NET.DebugInfo.DiTypeKind)"/>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DICompileUnit">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#dicompileunit"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DICompositeType">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#dicompositetype"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIDerivedType">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#diderivedtype"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIEnumerator">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#dienumerator"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIExpression">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#diexpression"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIFile">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#difile"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIGlobalVariable">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#diglobalvariable"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIImportedEntity">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#diImportedEntity"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DILexicalBlock">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#dilexicalblock"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DILexicalBlockFile">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#dilexicalblockfile"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DILocalScope">
            <summary>Legal scope for lexical blocks, local variables, and debug info locations</summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DILocalVariable">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#dilocalvariable"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DINamespace">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#dinamespace"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DINode">
            <summary>Root of the object hierarchy for Debug information metadata nodes</summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DINode.Tag">
            <summary>Dwarf tag for the descriptor</summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIScope">
            <summary>Base class for all Debug info scopes</summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DISubProgram">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#disubprogram"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DISubRange">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#disubrange"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DISubroutineType">
            <summary>see <a href="http://llvm.org/docs/LangRef.html#disubroutinetype"/></summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DIType">
            <summary>Base class for Debug info types</summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DITypeArray">
            <summary>Array of see <a href="Type"/> nodes for use with see <a href="DebugInfoBuilder"/> methods</summary>
        </member>
        <member name="T:Llvm.NET.DebugInfo.IDebugType`2">
            <summary>Provides pairing of a <see cref="T:Llvm.NET.Types.ITypeRef"/> with a <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.DIType"/> for function signatures</summary>
            <remarks>
            <para>Primitive types and function signature types are all interned in LLVM, thus there won't be a
            strict one to one relationship between an LLVM type and corresponding language specific debug
            type. (e.g. unsigned char, char, byte and signed byte might all be 8 bit integer values as far
            as LLVM is concerned. Also, when using the pointer+alloca+memcpy pattern to pass by value the
            actual source debug info type is different than the LLVM function signature. This class is used
            to construct native type and debug info pairing to allow applications to maintain a link from
            their AST or IR types into the LLVM native type and debug information.
            </para>
            <note type="note">
            It is important to note that the relationship between the <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.DIType"/> to it's <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.NativeType"/>
            properties is strictly one way. That is, there is no way to take an arbitrary <see cref="T:Llvm.NET.Types.ITypeRef"/> and re-associate
            it with the DIType or an implementation of this interface as there may be many such mappings to choose from.
            </note>
            </remarks>
        </member>
        <member name="P:Llvm.NET.DebugInfo.IDebugType`2.NativeType">
            <summary>LLVM NativeType this interface is associating with debug info in <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.DIType"/></summary>
        </member>
        <member name="P:Llvm.NET.DebugInfo.IDebugType`2.DIType">
            <summary>Debug information type this interface is associating with <see cref="P:Llvm.NET.DebugInfo.IDebugType`2.NativeType"/></summary>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugType.Create``2(``0,``1)">
            <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DebugType"/>instance inferring the generic arguments from the parameters</summary>
            <typeparam name="TNative">Type of the Native LLVM type for the association</typeparam>
            <typeparam name="TDebug">Type of the debug information type for the association</typeparam>
            <param name="nativeType"><typeparamref name="TNative"/> type instance for this association</param>
            <param name="debugType"><typeparamref name="TDebug"/> type instance for this association</param>
            <returns><see cref="T:Llvm.NET.DebugInfo.IDebugType`2"/> implementation for the specified association</returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugType.HasDebugInfo(Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType})">
            <summary>Convenience extensions for determining if the <see cref="T:Llvm.NET.DebugInfo.DIType"/> property is valid</summary>
            <param name="debugType"></param>
            <remarks>In LLVM Debug information a <see langword="null"/> <see cref="T:Llvm.NET.DebugInfo.DIType"/> is
            used to represent the void type. Thus, looking only at the <see cref="T:Llvm.NET.DebugInfo.DIType"/> property is
            insufficient to distinguish between a type with no debug information and one representing the void
            type. This property is used to disambiguate the two possibilities.
            </remarks>
        </member>
        <member name="T:Llvm.NET.DebugInfo.TupleTypedArrayWrapper`1">
            <summary>Generic wrapper to treat an MDTuple as an array of elements of specific type</summary>
            <typeparam name="T">Type of elements</typeparam>
            <remarks>
            This treats the operands of a tuple as the elements of the array
            </remarks>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugBasicType">
            <summary>Debug information binding between an LLVM native <see cref="T:Llvm.NET.Types.ITypeRef"/> and a <see cref="T:Llvm.NET.DebugInfo.DIBasicType"/></summary>
            <remarks>
            This class provides a binding between an LLVM type and a corresponding <see cref="T:Llvm.NET.DebugInfo.DIBasicType"/>.
            In LLVM all primitive types are unnamed and interned. That is, any use of an i8 is always the same
            type. However, at the source language level it is common to have named primitive types that map
            to the same underlying LLVM. For example, in C and C++ char maps to i8 but so does unsigned char
            (LLVM integral types don't have signed vs unsigned). This class is designed to handle this sort
            of one to many mapping of the lower level LLVM types to source level debugging types. Each
            instance of this class represents a source level basic type and the corresponding representation
            for LLVM.
            </remarks>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugBasicType.#ctor(Llvm.NET.Types.ITypeRef,Llvm.NET.NativeModule,System.String,Llvm.NET.DebugInfo.DiTypeKind)">
            <summary>Create a debug type for a basic type</summary>
            <param name="llvmType">Type to wrap debug information for</param>
            <param name="module">Module to use when constructing the debug information</param>
            <param name="name">Source language name of the type</param>
            <param name="encoding">Encoding for the type</param>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugFunctionType">
            <summary>This class provides debug information binding for an <see cref="T:Llvm.NET.Types.IFunctionType"/>
            and a <see cref="T:Llvm.NET.DebugInfo.DISubroutineType"/>
            </summary>
            <remarks>
            <para>Function signatures are unnamed interned types in LLVM. While there is usually a one
            to one mapping between an LLVM function signature type and the source language debug
            signature type that isn't always true. In particular, when passing data by value. In
            cases where the address of a by value structure is needed a common pattern is to use
            a pointer to the structure in the signature, then perform an Alloca + memcpy. The
            actual approach taken depends on the calling conventions of the target. In these cases
            you get an LLVM signature that doesn't match the source and could actually match another
            source function where a pointer to the structure is actually used in the source.</para>
            <para>For example, the following two C language functions might use the same LLVM signature:
            <code>void foo(struct bar)</code>
            <code>void foo2(struct bar*)</code>
            Implementing both of those might be done in LLVM with a single signature:
            <code>void (%struct.bar*)</code></para>
            <para>This class is designed to provide mapping between the debug signature type
            and the underlying LLVM type</para>
            <note type="note">It is important to keep in mind that signatures are only concerned
            with types. That is, they do not include names of parameters. Parameter information is
            provided by <see cref="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateArgument(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DIType,System.Boolean,Llvm.NET.DebugInfo.DebugInfoFlags,System.UInt16)"/>
            and <see cref="O:Llvm.NET.DebugInfo.DebugInfoBuilder.InsertDeclare"/></note>
            </remarks>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugFunctionType.#ctor(Llvm.NET.Types.IFunctionType,Llvm.NET.NativeModule,Llvm.NET.DebugInfo.DebugInfoFlags,Llvm.NET.DebugInfo.DebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.DebugInfo.DebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}[])">
            <summary>Constructs a new <see cref="T:Llvm.NET.DebugInfo.DebugFunctionType"/></summary>
            <param name="llvmType">Native LLVM function signature</param>
            <param name="module"><see cref="T:Llvm.NET.NativeModule"/> to use when construction debug information</param>
            <param name="debugFlags"><see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags"/> for this signature</param>
            <param name="retType">Return type for the function</param>
            <param name="argTypes">Potentially empty set of argument types for the signature</param>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugFunctionType.IsVarArg">
            <inheritdoc/>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugFunctionType.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugFunctionType.ParameterTypes">
            <inheritdoc/>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugInfoBuilder">
            <summary>DebugInfoBuilder is a factory class for creating DebugInformation for an LLVM
            <see cref="T:Llvm.NET.NativeModule"/></summary>
            <remarks>
            Many Debug information metadata nodes are created with unresolved references to additional
            metadata. To ensure such metadata is resolved applications should call the <see cref="M:Llvm.NET.DebugInfo.DebugInfoBuilder.Finish"/>
            method to resolve and finalize the metadata. After this point only fully resolved nodes may
            be added to ensure that the data remains valid.
            </remarks>
        </member>
        <member name="P:Llvm.NET.DebugInfo.DebugInfoBuilder.OwningModule">
            <summary>Module that owns this builder</summary>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateCompileUnit(Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DICompileUnit"/></summary>
            <param name="language"><see cref="T:Llvm.NET.DebugInfo.SourceLanguage"/> for the compilation unit</param>
            <param name="sourceFilePath">Full path to the source file of this compilation unit</param>
            <param name="producer">Name of the application processing the compilation unit</param>
            <param name="optimized">Flag to indicate if the code in this compilation unit is optimized</param>
            <param name="compilationFlags">Additional tool specific flags</param>
            <param name="runtimeVersion">Runtime version</param>
            <returns><see cref="T:Llvm.NET.DebugInfo.DICompileUnit"/></returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateCompileUnit(Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DICompileUnit"/></summary>
            <param name="language"><see cref="T:Llvm.NET.DebugInfo.SourceLanguage"/> for the compilation unit</param>
            <param name="fileName">Name of the source file of this compilation unit (without any path)</param>
            <param name="fileDirectory">Path of the directory containing the file</param>
            <param name="producer">Name of the application processing the compilation unit</param>
            <param name="optimized">Flag to indicate if the code in this compilation unit is optimized</param>
            <param name="compilationFlags">Additional tool specific flags</param>
            <param name="runtimeVersion">Runtime version</param>
            <returns><see cref="T:Llvm.NET.DebugInfo.DICompileUnit"/></returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateNamespace(Llvm.NET.DebugInfo.DIScope,System.String,System.Boolean)">
            <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DINamespace"/></summary>
            <param name="scope">Containing scope for the namespace or null if the namespace is a global one</param>
            <param name="name">Name of the namespace</param>
            <param name="exportSymbols">export symbols</param>
            <returns></returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateFile(System.String)">
            <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DIFile"/></summary>
            <param name="path">Path of the file (may be <see langword="null"/> or empty)</param>
            <returns>
            <see cref="T:Llvm.NET.DebugInfo.DIFile"/> or <see langword="null"/> if <paramref name="path"/>
            is <see langword="null"/> empty, or all whitespace
            </returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateFile(System.String,System.String)">
            <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DIFile"/></summary>
            <param name="fileName">Name of the file (may be <see langword="null"/> or empty)</param>
            <param name="directory">Path of the directory containing the file (may be <see langword="null"/> or empty)</param>
            <returns>
            <see cref="T:Llvm.NET.DebugInfo.DIFile"/> or <see langword="null"/> if <paramref name="fileName"/>
            is <see langword="null"/> empty, or all whitespace
            </returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateLexicalBlock(Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32,System.UInt32)">
            <summary>Creates a new <see cref="T:Llvm.NET.DebugInfo.DILexicalBlock"/></summary>
            <param name="scope"><see cref="T:Llvm.NET.DebugInfo.DIScope"/> for the block</param>
            <param name="file"><see cref="T:Llvm.NET.DebugInfo.DIFile"/> containing the block</param>
            <param name="line">Starting line number for the block</param>
            <param name="column">Starting column for the block</param>
            <returns>
            <see cref="T:Llvm.NET.DebugInfo.DILexicalBlock"/> created from the parameters
            </returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateLexicalBlockFile(Llvm.NET.DebugInfo.DIScope,Llvm.NET.DebugInfo.DIFile,System.UInt32)">
            <summary>Creates a <see cref="T:Llvm.NET.DebugInfo.DILexicalBlockFile"/></summary>
            <param name="scope"><see cref="T:Llvm.NET.DebugInfo.DIScope"/> for the block</param>
            <param name="file"><see cref="T:Llvm.NET.DebugInfo.DIFile"/></param>
            <param name="discriminator">Discriminator to disambiguate lexical blocks with the same file info</param>
            <returns>
            <see cref="T:Llvm.NET.DebugInfo.DILexicalBlockFile"/> constructed from the parameters
            </returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateFunction(Llvm.NET.DebugInfo.DIScope,System.String,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DISubroutineType,System.Boolean,System.Boolean,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Boolean,Llvm.NET.Values.Function,Llvm.NET.MDNode,Llvm.NET.MDNode)">
            <summary>Create a <see cref="T:Llvm.NET.DebugInfo.DISubProgram"/> with debug information</summary>
            <param name="scope"><see cref="T:Llvm.NET.DebugInfo.DIScope"/> for the function</param>
            <param name="name">Name of the function as it appears in the source language</param>
            <param name="mangledName">Linkage (mangled) name of the function</param>
            <param name="file"><see cref="T:Llvm.NET.DebugInfo.DIFile"/> containing the function</param>
            <param name="line">starting line of the function definition</param>
            <param name="signatureType"><see cref="T:Llvm.NET.DebugInfo.DISubroutineType"/> for the function's signature type</param>
            <param name="isLocalToUnit">Flag to indicate if this function is local to the compilation unit or available externally</param>
            <param name="isDefinition">Flag to indicate if this is a definition or a declaration only</param>
            <param name="scopeLine">starting line of the first scope of the function's body</param>
            <param name="debugFlags"><see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags"/> for this function</param>
            <param name="isOptimized">Flag to indicate if this function is optimized</param>
            <param name="function">Underlying LLVM <see cref="T:Llvm.NET.Values.Function"/> to attach debug info to</param>
            <param name="typeParameter">Template parameter [default = null]</param>
            <param name="declaration">Template declarations [default = null]</param>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.ForwardDeclareFunction(Llvm.NET.DebugInfo.DIScope,System.String,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DISubroutineType,System.Boolean,System.Boolean,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Boolean)">
            <summary>Creates a new forward declaration to a function</summary>
            <param name="scope"><see cref="T:Llvm.NET.DebugInfo.DIScope"/> for the declaration</param>
            <param name="name">Name of the function as it appears in source</param>
            <param name="mangledName">mangled name of the function (for linker)</param>
            <param name="file">Source file location for the function</param>
            <param name="line">starting line of the declaration</param>
            <param name="subroutineType">Signature for the function</param>
            <param name="isLocalToUnit">Flag to indicate if this declaration is local to the compilation unit</param>
            <param name="isDefinition">Flag to indicate if this is a definition</param>
            <param name="scopeLine">Line of the first scope block</param>
            <param name="debugFlags"><see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags"/> for the function</param>
            <param name="isOptimized">Flag to indicate if the function is optimized</param>
            <returns></returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateArgument(Llvm.NET.DebugInfo.DIScope,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DIType,System.Boolean,Llvm.NET.DebugInfo.DebugInfoFlags,System.UInt16)">
            <summary>Creates an argument for a function as a <see cref="T:Llvm.NET.DebugInfo.DILocalVariable"/></summary>
            <param name="scope">Scope for the argument</param>
            <param name="name">Name of the argument</param>
            <param name="file"><see cref="T:Llvm.NET.DebugInfo.DIFile"/> containing the function this argument is declared in</param>
            <param name="line">Line number fort his argument</param>
            <param name="type">Debug type for this argument</param>
            <param name="alwaysPreserve">Flag to indicate if this argument is always preserved for debug view even if optimization would remove it</param>
            <param name="debugFlags"><see cref="T:Llvm.NET.DebugInfo.DebugInfoFlags"/> for this argument</param>
            <param name="argNo">One based argument index on the method (e.g the first argument is 1 not 0 )</param>
            <returns><see cref="T:Llvm.NET.DebugInfo.DILocalVariable"/> representing the function argument</returns>
        </member>
        <member name="M:Llvm.NET.DebugInfo.DebugInfoBuilder.CreateBasicType(System.String,System.UInt64,Llvm.NET.DebugInfo.DiTypeKind)">
            <summary>Construct debug information for a basic type (a.k.a. primitive type)</summary>
            <param name="name">Name of the type</param>
            <param name="bitSize">Bit size for the type</param>
            <param name="encoding"><see cref="T:Llvm.NET.DebugInfo.DiTypeKind"/> encoding for the type</param>
            <returns></returns>
        </member>
        <member name="T:Llvm.NET.DebugInfo.DebugInfoFlags">
            <summary>Accessibility flags</summary>
            <remarks>
            The three accessibility flags are mutually exclusive and rolled together
            in the first two bits.
            </remarks>
        </member>
        <member name="T:Llvm.NET.ExtensiblePropertyContainer">
            <summary>Common implementation of <see cref="T:Llvm.NET.IExtensiblePropertyContainer"/></summary>
            <remarks>
            This class implements <see cref="T:Llvm.NET.IExtensiblePropertyContainer"/> through an
            internal <see cref="T:System.Collections.Generic.Dictionary`2"/>
            </remarks>
        </member>
        <member name="M:Llvm.NET.ExtensiblePropertyContainer.AddExtendedPropertyValue(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Llvm.NET.ExtensiblePropertyContainer.TryGetExtendedPropertyValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="T:Llvm.NET.ExtensiblePropertyDescriptor`1">
            <summary>Provides consistent accessors for an extended property</summary>
            <typeparam name="T">Type of values stored in the property</typeparam>
            <remarks>
            This class is used to describe a property stored in a class implementing
            <see cref="T:Llvm.NET.IExtensiblePropertyContainer"/>. Using a single, typically
            <see langword="static"/>, instance of this class to describe and access
            an extended property helps to encapsulate the type casting and property
            ID into a single place. Making calling code easier to comprehend and
            less prone to typographical errors that a compiler can't catch ahead of
            time.
            </remarks>
        </member>
        <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.#ctor(System.String)">
            <summary>Creates a new instance of a property descriptor</summary>
            <param name="name">Name of the extended property</param>
        </member>
        <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.GetValueFrom(Llvm.NET.IExtensiblePropertyContainer)">
            <summary>Gets a value for the property from the container</summary>
            <param name="container">container</param>
            <returns>Value retrieved from the property or the default value of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.GetValueFrom(Llvm.NET.IExtensiblePropertyContainer,`0)">
            <summary>Gets a value for the property from the container</summary>
            <param name="container">container</param>
            <param name="defaultValue">default value if the value is not yet present as an extended property</param>
            <returns>Value retrieved from the property or <paramref name="defaultValue"/> if it wasn't found</returns>
            <remarks>If the value didn't exist a new value with <paramref name="defaultValue"/> is added to the container</remarks>
        </member>
        <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.GetValueFrom(Llvm.NET.IExtensiblePropertyContainer,System.Func{`0})">
            <summary>Gets a value for the property from the container</summary>
            <param name="container">container</param>
            <param name="lazyDefaultFactory">default value factory delegate to create the default value if the value is not yet present as an extended property</param>
            <returns>Value retrieved from the property or default value created by <paramref name="lazyDefaultFactory"/> if it wasn't found</returns>
            <remarks>If the value didn't exist a new value created by calling with <paramref name="lazyDefaultFactory"/> is added to the container</remarks>
        </member>
        <member name="M:Llvm.NET.ExtensiblePropertyDescriptor`1.SetValueIn(Llvm.NET.IExtensiblePropertyContainer,`0)">
            <summary>Sets the value of an extended property in a container</summary>
            <param name="container">Container to set the value in</param>
            <param name="value">value of the property</param>
        </member>
        <member name="P:Llvm.NET.ExtensiblePropertyDescriptor`1.Name">
            <summary>Name of the property</summary>
        </member>
        <member name="T:Llvm.NET.Instructions.InstructionExtensions">
            <summary>Provides extension methods to <see cref="T:Llvm.NET.Instructions.Instruction"/> that cannot be achieved as members of the class</summary>
            <remarks>
            Using generic static extension methods allows for fluent coding while retaining the type of the "this" parameter.
            If these were members of the <see cref="T:Llvm.NET.Instructions.Instruction"/> class then the only return type could be <see cref="T:Llvm.NET.Instructions.Instruction"/>
            thus losing the original type and requiring a cast to get back to it, thereby defeating the purpose of the fluent style.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionExtensions.Alignment``1(``0,System.UInt32)">
            <summary>Fluent style extension method to set the <see cref="P:Llvm.NET.Instructions.Instruction.Alignment"/> for an instruction</summary>
            <typeparam name="T">Type of the instruction (usually implicitly inferred from usage)</typeparam>
            <param name="self">Instruction to set the <see cref="P:Llvm.NET.Instructions.Instruction.Alignment"/> for</param>
            <param name="value">New alignment for the instruction</param>
            <returns>To allow fluent style coding this returns the <paramref name="self"/> parameter</returns>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionExtensions.IsVolatile``1(``0,System.Boolean)">
            <summary>Fluent style extension method to set the Volatile property of a <see cref="T:Llvm.NET.Instructions.Load"/> or <see cref="T:Llvm.NET.Instructions.Store"/> instruction</summary>
            <typeparam name="T">Type of the instruction (usually implicitly inferred from usage)</typeparam>
            <param name="self">Instruction to set the Volatile property for</param>
            <param name="value">Flag to indicate if the instruction's operation is volatile</param>
            <returns>To allow fluent style coding this returns the <paramref name="self"/> parameter</returns>
        </member>
        <member name="T:Llvm.NET.Instructions.InstructionBuilder">
            <summary>LLVM Instruction builder allowing managed code to generate IR instructions</summary>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.#ctor(Llvm.NET.Context)">
            <summary>Initializes a new instance of the <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/> class for a given <see cref="T:Llvm.NET.Context"/></summary>
            <param name="context">Context used for creating instructions</param>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.#ctor(Llvm.NET.Values.BasicBlock)">
            <summary>Initializes a new instance of the <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/> class for a <see cref="T:Llvm.NET.Values.BasicBlock"/></summary>
            <param name="block">Block this builder is initially attached to</param>
        </member>
        <member name="P:Llvm.NET.Instructions.InstructionBuilder.Context">
            <summary>Gets the context this builder is creating instructions for</summary>
        </member>
        <member name="P:Llvm.NET.Instructions.InstructionBuilder.InsertBlock">
            <summary>Gets the <see cref="T:Llvm.NET.Values.BasicBlock"/> this builder is building instructions for</summary>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.PositionAtEnd(Llvm.NET.Values.BasicBlock)">
            <summary>Positions the builder at the end of a given <see cref="T:Llvm.NET.Values.BasicBlock"/></summary>
            <param name="basicBlock">Block to set the poition of</param>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.PositionBefore(Llvm.NET.Instructions.Instruction)">
            <summary>Positions the builder before the given instruction</summary>
            <param name="instr">Instruction to position the builder before</param>
            <remarks>This method will position the builder to add new instructions
            immediately before the specified instruction.
            <note type="note">It is important to keep in mind that this can change the
            block this builder is targeting. That is, <paramref name="instr"/>
            is not required to come from the same block the instruction builder is
            currently referencing.</note>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.Store(Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
            <summary>Builds an LLVM Store instruction</summary>
            <param name="value">Value to store in destination</param>
            <param name="destination">value for the destination</param>
            <returns><see cref="T:Llvm.NET.Instructions.Store"/> instruction</returns>
            <remarks>
            Since store targets memory the type of <paramref name="destination"/>
            must be an <see cref="T:Llvm.NET.Types.IPointerType"/>. Furthermore, the element type of
            the pointer must match the type of <paramref name="value"/>. Otherwise,
            an <see cref="T:System.ArgumentException"/> is thrown.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetStructElementPointer(Llvm.NET.Values.Value,System.UInt32)">
            <summary>Creates a <see cref="T:Llvm.NET.Values.Value"/> that accesses an element (field) of a structure</summary>
            <param name="pointer">pointer to the structure to get an element from</param>
            <param name="index">element index</param>
            <returns>
            <para><see cref="T:Llvm.NET.Values.Value"/> for the member access. This is a <see cref="T:Llvm.NET.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression"/>
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetElementPtr(Llvm.NET.Values.Value,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Value})">
            <summary>Creates a <see cref="T:Llvm.NET.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Llvm.NET.Values.Value"/> for the member access. This is a <see cref="T:Llvm.NET.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression"/>
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see http://llvm.org/docs/GetElementPtr.html. The
            basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However, that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. In order to properly compute the offset for a given
            element in an aggregate type LLVM requires an explicit first index even if it is zero.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetElementPtrInBounds(Llvm.NET.Values.Value,Llvm.NET.Values.Value[])">
            <summary>Creates a <see cref="T:Llvm.NET.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Llvm.NET.Values.Value"/> for the member access. This is a <see cref="T:Llvm.NET.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression"/>
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see http://llvm.org/docs/GetElementPtr.html. The
            basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. In order to properly compute the offset for a given
            element in an aggregate type LLVM requires an explicit first index even if it is zero.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.GetElementPtrInBounds(Llvm.NET.Values.Value,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Value})">
            <summary>Creates a <see cref="T:Llvm.NET.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Llvm.NET.Values.Value"/> for the member access. This is a <see cref="T:Llvm.NET.Values.Value"/>
            as LLVM may optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression"/>
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see http://llvm.org/docs/GetElementPtr.html. The
            basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However, that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. In order to properly compute the offset for a given
            element in an aggregate type LLVM requires an explicit first index even if it is zero.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.ConstGetElementPtrInBounds(Llvm.NET.Values.Value,Llvm.NET.Values.Value[])">
            <summary>Creates a <see cref="T:Llvm.NET.Values.Value"/> that accesses an element of a type referenced by a pointer</summary>
            <param name="pointer">pointer to get an element from</param>
            <param name="args">additional indices for computing the resulting pointer</param>
            <returns>
            <para><see cref="T:Llvm.NET.Values.Value"/> for the member access. This is a User as LLVM may
            optimize the expression to a <see cref="T:Llvm.NET.Values.ConstantExpression"/> if it
            can so the actual type of the result may be <see cref="T:Llvm.NET.Values.ConstantExpression"/>
            or <see cref="T:Llvm.NET.Instructions.GetElementPtr"/>.</para>
            <para>Note that <paramref name="pointer"/> must be a pointer to a structure
            or an exception is thrown.</para>
            </returns>
            <remarks>
            For details on GetElementPointer (GEP) see http://llvm.org/docs/GetElementPtr.html. The
            basic gist is that the GEP instruction does not access memory, it only computes a pointer
            offset from a base. A common confusion is around the first index and what it means. For C
            and C++ programmers an expression like pFoo->bar seems to only have a single offset or
            index. However that is only syntactic sugar where the compiler implicitly hides the first
            index. That is, there is no difference between pFoo[0].bar and pFoo->bar except that the
            former makes the first index explicit. LLVM requires an explicit first index even if it is
            zero, in order to properly compute the offset for a given element in an aggregate type.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.IntToPointer(Llvm.NET.Values.Value,Llvm.NET.Types.IPointerType)">
            <summary>Builds a cast from an integer to a pointer</summary>
            <param name="intValue">Integer value to cast</param>
            <param name="ptrType">pointer type to return</param>
            <returns>Resulting value from the cast</returns>
            <remarks>
            The actual type of value returned depends on <paramref name="intValue"/>
            and is either a <see cref="T:Llvm.NET.Values.ConstantExpression"/> or an <see cref="T:Llvm.NET.Instructions.IntToPointer"/>
            instruction. Conversion to a constant expression is performed whenever possible.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.PointerToInt(Llvm.NET.Values.Value,Llvm.NET.Types.ITypeRef)">
            <summary>Builds a cast from a pointer to an integer type</summary>
            <param name="ptrValue">Pointer value to cast</param>
            <param name="intType">Integer type to return</param>
            <returns>Resulting value from the cast</returns>
            <remarks>
            The actual type of value returned depends on <paramref name="ptrValue"/>
            and is either a <see cref="T:Llvm.NET.Values.ConstantExpression"/> or a <see cref="T:Llvm.NET.Instructions.PointerToInt"/>
            instruction. Conversion to a constant expression is performed whenever possible.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.Compare(Llvm.NET.IntPredicate,Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
            <summary>Builds an Integer compare instruction</summary>
            <param name="predicate">Integer predicate for the comparison</param>
            <param name="lhs">Left hand side of the comparison</param>
            <param name="rhs">Right hand side of the comparison</param>
            <returns>Comparison instruction</returns>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.Compare(Llvm.NET.RealPredicate,Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
            <summary>Builds a Floating point compare instruction</summary>
            <param name="predicate">predicate for the comparison</param>
            <param name="lhs">Left hand side of the comparison</param>
            <param name="rhs">Right hand side of the comparison</param>
            <returns>Comparison instruction</returns>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.Compare(Llvm.NET.Predicate,Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
            <summary>Builds a compare instruction</summary>
            <param name="predicate">predicate for the comparison</param>
            <param name="lhs">Left hand side of the comparison</param>
            <param name="rhs">Right hand side of the comparison</param>
            <returns>Comparison instruction</returns>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.Select(Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value)">
            <summary>Builds a <see cref="T:Llvm.NET.Instructions.Select"/> instruction</summary>
            <param name="ifCondition">Value for the condition to select between the values</param>
            <param name="thenValue">Result value if <paramref name="ifCondition"/> evaluates to 1</param>
            <param name="elseValue">Result value if <paramref name="ifCondition"/> evaluates to 0</param>
            <returns>Selected value</returns>
            <remarks>
            If <paramref name="ifCondition"/> is a vector then both values must be a vector of the same
            size and the selection is performed element by element. The values must be the same type.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemCpy(Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
            <summary>Builds a memcpy intrinsic call</summary>
            <param name="destination">Destination pointer of the memcpy</param>
            <param name="source">Source pointer of the memcpy</param>
            <param name="len">length of the data to copy</param>
            <param name="align">Alignment of the data for the copy</param>
            <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
            <returns><see cref="T:Llvm.NET.Instructions.Intrinsic"/> call for the memcpy</returns>
            <remarks>
            LLVM has many overloaded variants of the memcpy intrinsic, this implementation will deduce the types from
            the provided values and generate a more specific call without the need to provide overloaded forms of this
            method and otherwise complicating the calling code.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemCpy(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
            <summary>Builds a memcpy intrinsic call</summary>
            <param name="module">Module to add the declaration of the intrinsic to if it doesn't already exist</param>
            <param name="destination">Destination pointer of the memcpy</param>
            <param name="source">Source pointer of the memcpy</param>
            <param name="len">length of the data to copy</param>
            <param name="align">Alignment of the data for the copy</param>
            <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
            <returns><see cref="T:Llvm.NET.Instructions.Intrinsic"/> call for the memcpy</returns>
            <remarks>
            LLVM has many overloaded variants of the memcpy intrinsic, this implementation will deduce the types from
            the provided values and generate a more specific call without the need to provide overloaded forms of this
            method and otherwise complicating the calling code.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemMove(Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
            <summary>Builds a memmov intrinsic call</summary>
            <param name="destination">Destination pointer of the memmov</param>
            <param name="source">Source pointer of the memmov</param>
            <param name="len">length of the data to copy</param>
            <param name="align">Alignment of the data for the copy</param>
            <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
            <returns><see cref="T:Llvm.NET.Instructions.Intrinsic"/> call for the memmov</returns>
            <remarks>
            LLVM has many overloaded variants of the memmov intrinsic, this implementation currently assumes the
            single form defined by <see cref="F:Llvm.NET.Instructions.Intrinsic.MemMoveName"/>, which matches the classic "C" style memmov
            function. However future implementations should be able to deduce the types from the provided values
            and generate a more specific call without changing any caller code (as is done with
            <see cref="M:Llvm.NET.Instructions.InstructionBuilder.MemCpy(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)"/>.)
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemMove(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
            <summary>Builds a memmov intrinsic call</summary>
            <param name="module">Module to add the declaration of the intrinsic to if it doesn't already exist</param>
            <param name="destination">Destination pointer of the memmov</param>
            <param name="source">Source pointer of the memmov</param>
            <param name="len">length of the data to copy</param>
            <param name="align">Alignment of the data for the copy</param>
            <param name="isVolatile">Flag to indicate if the copy involves volatile data such as physical registers</param>
            <returns><see cref="T:Llvm.NET.Instructions.Intrinsic"/> call for the memmov</returns>
            <remarks>
            LLVM has many overloaded variants of the memmov intrinsic, this implementation currently assumes the
            single form defined by <see cref="F:Llvm.NET.Instructions.Intrinsic.MemMoveName"/>, which matches the classic "C" style memmov
            function. However future implementations should be able to deduce the types from the provided values
            and generate a more specific call without changing any caller code (as is done with
            <see cref="M:Llvm.NET.Instructions.InstructionBuilder.MemCpy(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)"/>.)
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemSet(Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
            <summary>Builds a memset intrinsic call</summary>
            <param name="destination">Destination pointer of the memset</param>
            <param name="value">fill value for the memset</param>
            <param name="len">length of the data to fill</param>
            <param name="align">ALignment of the data for the fill</param>
            <param name="isVolatile">Flag to indicate if the fill involves volatile data such as physical registers</param>
            <returns><see cref="T:Llvm.NET.Instructions.Intrinsic"/> call for the memset</returns>
            <remarks>
            LLVM has many overloaded variants of the memset intrinsic, this implementation currently assumes the
            single form defined by <see cref="F:Llvm.NET.Instructions.Intrinsic.MemSetName"/>, which matches the classic "C" style memset
            function. However future implementations should be able to deduce the types from the provided values
            and generate a more specific call without changing any caller code (as is done with
            <see cref="M:Llvm.NET.Instructions.InstructionBuilder.MemCpy(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)"/>.)
            </remarks>
        </member>
        <member name="M:Llvm.NET.Instructions.InstructionBuilder.MemSet(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)">
            <summary>Builds a memset intrinsic call</summary>
            <param name="module">Module to add the declaration of the intrinsic to if it doesn't already exist</param>
            <param name="destination">Destination pointer of the memset</param>
            <param name="value">fill value for the memset</param>
            <param name="len">length of the data to fill</param>
            <param name="align">ALignment of the data for the fill</param>
            <param name="isVolatile">Flag to indicate if the fill involves volatile data such as physical registers</param>
            <returns><see cref="T:Llvm.NET.Instructions.Intrinsic"/> call for the memset</returns>
            <remarks>
            LLVM has many overloaded variants of the memset intrinsic, this implementation currently assumes the
            single form defined by <see cref="F:Llvm.NET.Instructions.Intrinsic.MemSetName"/>, which matches the classic "C" style memset
            function. However future implementations should be able to deduce the types from the provided values
            and generate a more specific call without changing any caller code (as is done with
            <see cref="M:Llvm.NET.Instructions.InstructionBuilder.MemCpy(Llvm.NET.NativeModule,Llvm.NET.Values.Value,Llvm.NET.Values.Value,Llvm.NET.Values.Value,System.Int32,System.Boolean)"/>.)
            </remarks>
        </member>
        <member name="P:Llvm.NET.Instructions.Switch.Default">
            <summary>Default <see cref="T:Llvm.NET.Values.BasicBlock"/>for the switch</summary>
        </member>
        <member name="M:Llvm.NET.Instructions.Switch.AddCase(Llvm.NET.Values.Value,Llvm.NET.Values.BasicBlock)">
            <summary>Adds a new case to the <see cref="T:Llvm.NET.Instructions.Switch"/> instruction</summary>
            <param name="onVal">Value for the case to match</param>
            <param name="destination">Destination <see cref="T:Llvm.NET.Values.BasicBlock"/> if the case matches</param>
        </member>
        <member name="T:Llvm.NET.Instructions.Instruction">
            <summary>Exposes an LLVM Instruction</summary>
        </member>
        <member name="P:Llvm.NET.Instructions.Instruction.ContainingBlock">
            <summary>Block that contains this instruction</summary>
        </member>
        <member name="P:Llvm.NET.Instructions.Instruction.Opcode">
            <summary>Gets the LLVM opcode for the instruction</summary>
        </member>
        <member name="P:Llvm.NET.Instructions.Instruction.IsMemoryAccess">
            <summary>Flag to indicate if the opcode is for a memory access <see cref="T:Llvm.NET.Instructions.Alloca"/>, <see cref="T:Llvm.NET.Instructions.Load"/>, <see cref="T:Llvm.NET.Instructions.Store"/></summary>
        </member>
        <member name="P:Llvm.NET.Instructions.Instruction.Alignment">
            <summary>Alignment for the instruction</summary>
            <remarks>
            The alignment is always 0 for instructions other than Alloca, Load, and Store
            that deal with memory accesses. Setting the alignment for other instructions
            results in an InvalidOperationException()
            </remarks>
        </member>
        <member name="T:Llvm.NET.MDNodeOperandList">
            <summary>Support class to provide readonly list semantics to the operands of an MDNode</summary>
        </member>
        <member name="T:Llvm.NET.EnumerableExtensions">
            <summary>This is an internal duplicate of Extensions added to CoreFx.</summary>
            <remarks>
            This is duped here to enable use in down-level runtimes. Furthermore, it uses a different
            name and is marked internal to prevent conflicts with the official implementation when
            built for runtimes supporting that. (See: https://github.com/dotnet/corefx/pull/5947)
            </remarks>
        </member>
        <member name="T:Llvm.NET.Native.SafeHandleNullIsInvalid">
            <summary>Base class for LLVM disposable types that are instantiated outside of an LLVM <see cref="T:Llvm.NET.Context"/> and therefore won't be disposed by the context</summary>
        </member>
        <member name="M:Llvm.NET.Native.NativeMethods.#cctor">
            <summary>Static constructor for NativeMethods</summary>
        </member>
        <member name="M:Llvm.NET.Native.NativeMethods.LoadWin32Library(System.String,System.String)">
            <summary>Dynamically loads a DLL from a directory dependent on the current architecture</summary>
            <param name="moduleName">name of the DLL</param>
            <param name="rootPath">Root path to find the DLL from</param>
            <returns>Handle for the DLL</returns>
            <remarks>
            <para>This method will detect the architecture the code is executing on (i.e. x86 or x64)
            and will load the DLL from an architecture specific sub folder of <paramref name="rootPath"/>.
            This allows use of AnyCPU builds and interop to simplify build processes from needing to
            deal with "mixed" configurations or other accidental combinations that are a pain to
            sort out and keep straight when the tools insist on creating AnyCPU projects and "mixed" configurations
            by default.</para>
            <para>If the <paramref name="rootPath"/>Is <see langword="null"/>, empty or all whitespace then
            the standard DLL search paths are used. This assumes the correct variant of the DLL is available
            (e.g. for a 32 bit system a 32 bit native DLL is found). This allows for either building as AnyCPU
            plus shipping multiple native DLLs, or building for a specific CPU type while shipping only one native
            DLL. Different products or projects may have different needs so this covers those cases.
            </para>
            </remarks>
        </member>
        <member name="T:Llvm.NET.LlvmMetadata">
            <summary>Root of the LLVM Metadata hierarchy</summary>
            <remarks>In LLVM this is just "Metadata" however that name has the potential
            to conflict with the .NET runtime namespace of the same name, so the name
            is changed in the .NET bindings to avoid the conflict.</remarks>
        </member>
        <member name="M:Llvm.NET.LlvmMetadata.ReplaceAllUsesWith(Llvm.NET.LlvmMetadata)">
            <summary>Replace all uses of this descriptor with another</summary>
            <param name="other">New descriptor to replace this one with</param>
        </member>
        <member name="M:Llvm.NET.LlvmMetadata.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Llvm.NET.LlvmMetadata.MetadataKind">
            <summary>Enumeration to define debug information metadata nodes</summary>
        </member>
        <member name="T:Llvm.NET.NamedMDNode">
            <summary>Wraps an LLVM NamedMDNode</summary>
            <remarks>Despite its name a NamedMDNode is not itself an MDNode.</remarks>
        </member>
        <member name="T:Llvm.NET.Triple">
            <summary>Triple to describe a target</summary>
            <remarks>
            <para>The term 'Triple' is a bit of a misnomer. At some point in the past it
            actually consisted of only three parts, but that has changed over the years
            without the name itself changing. The triple is normally represented as a
            string of 4 components delimited by '-'. Some of the components have
            sub components as part of the content. The canonical form of a triple is:
            <c>{Architecture}{SubArchitecture}-{Vendor}-{OS}-{Environment}{ObjectFormat}</c></para>
            <para>
            A few shorthand variations are allowed and converted to their full normalized form.
            In particular "cygwin" is a shorthand for the OS-Environment tuple "windows-cygnus"
            and "mingw" is a shorthand form of "windows-gnu".
            </para>
            <para>In addition to shorthand allowances, the OS component may optionally include
            a trailing version of the form Maj.Min.Micro. If any of the version number parts are
            not present, then they default to 0.</para>
            <para>
            For the environment "androideabi" is allowed and normalized to android (including
            an optional version number).
            </para>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Triple.#ctor(System.String)">
            <summary>Constructs a new <see cref="T:Llvm.NET.Triple"/> instance from a triple string</summary>
            <param name="tripleTxt">Triple string to parse</param>
            <remarks>
            The <paramref name="tripleTxt"/> string is normalized before parsing to allow for
            common non-canonical forms of triples.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Triple.ToString">
            <summary>Retrieves the final string form of the triple</summary>
            <returns>Normalized Triple string</returns>
        </member>
        <member name="P:Llvm.NET.Triple.ArchitectureType">
            <summary>Architecture of the triple</summary>
        </member>
        <member name="P:Llvm.NET.Triple.SubArchitecture">
            <summary>Sub Architecture type</summary>
        </member>
        <member name="P:Llvm.NET.Triple.VendorType">
            <summary>Vendor component of the triple</summary>
        </member>
        <member name="P:Llvm.NET.Triple.OSType">
            <summary>OS Type for the triple</summary>
        </member>
        <member name="P:Llvm.NET.Triple.EnvironmentType">
            <summary>Environment type for the triple</summary>
        </member>
        <member name="P:Llvm.NET.Triple.ObjectFormatType">
            <summary>Object format type for the triple</summary>
        </member>
        <member name="M:Llvm.NET.Triple.GetCanonicalName(Llvm.NET.TripleArchType)">
            <summary>Retrieves the canonical name for an architecture type</summary>
            <param name="archType">Architecture type</param>
            <returns>String name for the architecture</returns>
            <overloads>
            Many parts of a triple can take a variety of literal string
            forms to allow for common real world triples when parsing.
            The GetCanonicalName methods provide the canonical form of
            such triple components used in a normalized triple.
            </overloads>
        </member>
        <member name="M:Llvm.NET.Triple.GetCanonicalName(Llvm.NET.TripleSubArchType)">
            <summary>Retrieves the canonical name for an architecture sub type</summary>
            <param name="subArchType">Architecture sub type</param>
            <returns>String name for the architecture sub type</returns>
        </member>
        <member name="M:Llvm.NET.Triple.GetCanonicalName(Llvm.NET.TripleVendorType)">
            <summary>Retrieves the canonical name for the vendor component of a triple</summary>
            <param name="vendorType">Vendor type</param>
            <returns>String name for the vendor</returns>
        </member>
        <member name="M:Llvm.NET.Triple.GetCanonicalName(Llvm.NET.TripleOSType)">
            <summary>Retrieves the canonical name for the OS component of a triple</summary>
            <param name="osType">OS type</param>
            <returns>String name for the OS</returns>
        </member>
        <member name="M:Llvm.NET.Triple.GetCanonicalName(Llvm.NET.TripleEnvironmentType)">
            <summary>Retrieves the canonical name for the environment component of a triple</summary>
            <param name="envType">Environment type</param>
            <returns>String name for the environment component</returns>
        </member>
        <member name="M:Llvm.NET.Triple.GetCanonicalName(Llvm.NET.TripleObjectFormatType)">
            <summary>Retrieves the canonical name for the object component of a triple</summary>
            <param name="objFormatType">Object type</param>
            <returns>String name for the object component</returns>
        </member>
        <member name="M:Llvm.NET.Triple.Equals(Llvm.NET.Triple)">
            <summary>Equality test for a triple</summary>
            <param name="other">triple to compare this triple to</param>
            <returns><see langword="true"/> if the two triples are equivalent</returns>
        </member>
        <member name="M:Llvm.NET.Triple.Equals(System.Object)">
            <summary>Equality test for a triple</summary>
            <param name="obj">object to compare this triple to</param>
            <returns><see langword="true"/> if the two triples are equivalent</returns>
        </member>
        <member name="M:Llvm.NET.Triple.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Llvm.NET.Triple.Normalize(System.String)">
            <summary>Normalizes a triple string</summary>
            <param name="unNormalizedTriple">triple to normalize</param>
            <returns>Normalized string</returns>
        </member>
        <member name="M:Llvm.NET.Triple.GetDefaultObjectFormat(Llvm.NET.TripleArchType,Llvm.NET.TripleOSType)">
            <summary>Gets the default <see cref="T:Llvm.NET.TripleObjectFormatType"/> for a given <see cref="T:Llvm.NET.TripleArchType"/> and <see cref="T:Llvm.NET.TripleOSType"/></summary>
            <param name="arch">Architecture type</param>
            <param name="os">Operating system type</param>
            <returns>Default object format</returns>
        </member>
        <member name="M:Llvm.NET.Triple.GetCanonicalArchForSubArch(Llvm.NET.TripleArchType,Llvm.NET.TripleSubArchType)">
            <summary>Provides the canonical Architecture form for a given architecture sub architecture pair</summary>
            <param name="archType">Architecture type</param>
            <param name="subArch">Sub Architecture type</param>
            <returns>Canonical <see cref="T:Llvm.NET.TripleArchType"/></returns>
            <remarks>
            Some architectures, particularly ARM variants, have multiple sub-architecture types that
            have a canonical form (i.e. Arch=<see cref="F:Llvm.NET.TripleArchType.Arm"/>; SubArch=<see cref="F:Llvm.NET.TripleSubArchType.ARMSubArch_v7m"/>;
            has the Canonical Arch of <see cref="F:Llvm.NET.TripleArchType.Thumb"/>). This method retrieves the canonical Arch
            for a given architecture,SubArchitecture pair.
            </remarks>
        </member>
        <member name="T:Llvm.NET.Types.ITypeRef">
            <summary>Interface for a Type in LLVM</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.TypeHandle">
            <summary>LibLLVM handle for the type</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsSized">
            <summary>Flag to indicate if the type is sized</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.Kind">
            <summary>LLVM Type kind for this type</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsInteger">
            <summary>Flag to indicate if this type is an integer</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsVoid">
            <summary>Flag to indicate if this type represents the void type</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsStruct">
            <summary>Flag to indicate if this type is a structure type</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsPointer">
            <summary>Flag to indicate if this type is a pointer</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsSequence">
            <summary>Flag to indicate if this type is a sequence type</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsFloatingPoint">
            <summary>Flag to indicate if this type is a floating point type</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IsPointerPointer">
            <summary>FLag to indicate if this type is a pointer to a pointer</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.Context">
            <summary>Context that owns this type</summary>
        </member>
        <member name="P:Llvm.NET.Types.ITypeRef.IntegerBitWidth">
            <summary>Integer bit width of this type or 0 for non integer types</summary>
        </member>
        <member name="M:Llvm.NET.Types.ITypeRef.GetNullValue">
            <summary>Gets a null value (e.g. all bits == 0 ) for the type</summary>
            <remarks>
            This is a getter function instead of a property as it can throw exceptions
            for types that don't support such a thing (i.e. void )
            </remarks>
        </member>
        <member name="M:Llvm.NET.Types.ITypeRef.CreateArrayType(System.UInt32)">
            <summary>Array type factory for an array with elements of this type</summary>
            <param name="count">Number of elements in the array</param>
            <returns><see cref="T:Llvm.NET.Types.IArrayType"/> for the array</returns>
        </member>
        <member name="M:Llvm.NET.Types.ITypeRef.CreatePointerType">
            <summary>Get a <see cref="T:Llvm.NET.Types.IPointerType"/> for a type that points to elements of this type in the default (0) address space</summary>
            <returns><see cref="T:Llvm.NET.Types.IPointerType"/>corresponding to the type of a pointer that refers to elements of this type</returns>
        </member>
        <member name="M:Llvm.NET.Types.ITypeRef.CreatePointerType(System.UInt32)">
            <summary>Get a <see cref="T:Llvm.NET.Types.IPointerType"/> for a type that points to elements of this type in the specified address space</summary>
            <param name="addressSpace">Address space for the pointer</param>
            <returns><see cref="T:Llvm.NET.Types.IPointerType"/>corresponding to the type of a pointer that refers to elements of this type</returns>
        </member>
        <member name="T:Llvm.NET.Types.IArrayType">
            <summary>Interface for an LLVM array type </summary>
        </member>
        <member name="P:Llvm.NET.Types.IArrayType.Length">
            <summary>Length of the array</summary>
        </member>
        <member name="T:Llvm.NET.Types.ArrayType">
            <summary>Array type definition</summary>
            <remarks>
            Array's in LLVM are fixed length sequences of elements
            </remarks>
        </member>
        <member name="P:Llvm.NET.Types.ArrayType.Length">
            <summary>Length of the array</summary>
        </member>
        <member name="T:Llvm.NET.Types.IFunctionType">
            <summary>Interface to represent the LLVM type of a function (e.g. a signature)</summary>
        </member>
        <member name="P:Llvm.NET.Types.IFunctionType.IsVarArg">
            <summary>Flag to indicate if this signature is for a variadic function</summary>
        </member>
        <member name="P:Llvm.NET.Types.IFunctionType.ReturnType">
            <summary>Return type of the function</summary>
        </member>
        <member name="P:Llvm.NET.Types.IFunctionType.ParameterTypes">
            <summary>Collection of types of the parameters for the function</summary>
        </member>
        <member name="T:Llvm.NET.Types.FunctionType">
            <summary>Class to represent the LLVM type of a function (e.g. a signature)</summary>
        </member>
        <member name="P:Llvm.NET.Types.FunctionType.IsVarArg">
            <inheritdoc/>
        </member>
        <member name="P:Llvm.NET.Types.FunctionType.ReturnType">
            <inheritdoc/>
        </member>
        <member name="P:Llvm.NET.Types.FunctionType.ParameterTypes">
            <inheritdoc/>
        </member>
        <member name="T:Llvm.NET.Types.ISequenceType">
            <summary>Interface for an LLVM sequence type</summary>
            <remarks>
            Sequence types represent a sequence of elements of the same type
            that are contiguous in memory. These include Vectors, Arrays, and
            pointers.
            </remarks>
        </member>
        <member name="P:Llvm.NET.Types.ISequenceType.ElementType">
            <summary>Type of elements in the sequence</summary>
        </member>
        <member name="T:Llvm.NET.Types.INamedStructuralType">
            <summary>Interface for a named type with members</summary>
            <remarks>This is a common interface for structures and unions</remarks>
        </member>
        <member name="P:Llvm.NET.Types.INamedStructuralType.Name">
            <summary>Name of the structure</summary>
        </member>
        <member name="P:Llvm.NET.Types.INamedStructuralType.IsOpaque">
            <summary>Indicates if the structure is opaque (e.g. has no body defined yet)</summary>
        </member>
        <member name="P:Llvm.NET.Types.INamedStructuralType.Members">
            <summary>List of types for all member elements of the structure</summary>
        </member>
        <member name="T:Llvm.NET.Types.IStructType">
            <summary>Interface for an LLVM structure type</summary>
        </member>
        <member name="P:Llvm.NET.Types.IStructType.IsPacked">
            <summary>Indicates if the structure is packed (e.g. no automatic alignment padding between elements)</summary>
        </member>
        <member name="M:Llvm.NET.Types.IStructType.SetBody(System.Boolean,Llvm.NET.Types.ITypeRef[])">
            <summary>Sets the body of the structure</summary>
            <param name="packed">Flag to indicate if the body elements are packed (e.g. no padding)</param>
            <param name="elements">Optional types of each element</param>
            <remarks>
            To set the body , at least one element type is required. If none are provided this is a NOP.
            </remarks>
        </member>
        <member name="T:Llvm.NET.Types.TypeRef">
            <summary>LLVM Type</summary>
        </member>
        <member name="P:Llvm.NET.Types.TypeRef.IsSized">
            <summary>Flag to indicate if the type is sized</summary>
        </member>
        <member name="P:Llvm.NET.Types.TypeRef.Kind">
            <summary>LLVM Type kind for this type</summary>
        </member>
        <member name="P:Llvm.NET.Types.TypeRef.IsSequence">
            <summary>Flag to indicate if the type is a sequence type</summary>
        </member>
        <member name="P:Llvm.NET.Types.TypeRef.Context">
            <summary>Context that owns this type</summary>
        </member>
        <member name="P:Llvm.NET.Types.TypeRef.IntegerBitWidth">
            <summary>Integer bid width of this type or 0 for non integer types</summary>
        </member>
        <member name="M:Llvm.NET.Types.TypeRef.GetNullValue">
            <summary>Gets a null value (e.g. all bits = 0 ) for the type</summary>
            <remarks>This is a getter function instead of a property as it can throw exceptions</remarks>
        </member>
        <member name="M:Llvm.NET.Types.TypeRef.CreateArrayType(System.UInt32)">
            <summary>Array type factory for an array with elements of this type</summary>
            <param name="count">Number of elements in the array</param>
            <returns><see cref="T:Llvm.NET.Types.IArrayType"/> for the array</returns>
        </member>
        <member name="M:Llvm.NET.Types.TypeRef.CreatePointerType">
            <summary>Get a <see cref="T:Llvm.NET.Types.IPointerType"/> for a type that points to elements of this type in the default (0) address space</summary>
            <returns><see cref="T:Llvm.NET.Types.IPointerType"/>corresponding to the type of a pointer that referns to elements of this type</returns>
        </member>
        <member name="M:Llvm.NET.Types.TypeRef.CreatePointerType(System.UInt32)">
            <summary>Get a <see cref="T:Llvm.NET.Types.IPointerType"/> for a type that points to elements of this type in the specified address space</summary>
            <param name="addressSpace">Address space for the pointer</param>
            <returns><see cref="T:Llvm.NET.Types.IPointerType"/>corresponding to the type of a pointer that referns to elements of this type</returns>
        </member>
        <member name="M:Llvm.NET.Types.TypeRef.ToString">
            <summary>Builds a string representation for this type in LLVM assembly language form</summary>
            <returns>Formatted string for this type</returns>
        </member>
        <member name="T:Llvm.NET.Types.IPointerType">
            <summary>Interface for a pointer type in LLVM</summary>
        </member>
        <member name="P:Llvm.NET.Types.IPointerType.AddressSpace">
            <summary>Address space the pointer refers to</summary>
        </member>
        <member name="T:Llvm.NET.Types.PointerType">
            <summary>LLVM pointer type</summary>
        </member>
        <member name="P:Llvm.NET.Types.PointerType.AddressSpace">
            <summary>Address space the pointer refers to</summary>
        </member>
        <member name="T:Llvm.NET.Values.Argument">
            <summary>An LLVM Value representing an Argument to a function</summary>
        </member>
        <member name="P:Llvm.NET.Values.Argument.ContainingFunction">
            <summary>Function this argument belongs to</summary>
        </member>
        <member name="P:Llvm.NET.Values.Argument.Index">
            <summary>Zero based index of the argument</summary>
        </member>
        <member name="M:Llvm.NET.Values.Argument.SetAlignment(System.UInt32)">
            <summary>Sets the alignment for the argument</summary>
            <param name="value">Alignment value for this argument</param>
        </member>
        <member name="T:Llvm.NET.Values.AttributeKind">
            <summary>Enumeration for the known LLVM attributes</summary>
            <remarks>
            <para>It is important to note that the integer values of this enum
            do NOT necessarily correlate to the attribute IDs. LLVM has
            moved away from using an enum Flags model as the number of
            attributes reached the limit of available bits. Thus, the
            enum was dropped as of V5.0. Instead, strings are used to
            identify attributes. However, for maximum compatibility and
            ease of use for this library the enum is retained and the
            provided attribute manipulation classes will map the enum
            to the associated string.</para>
            <para>Also note that as a reult of the changes in LLVM this
            set of attributes is fluid and subject to change from version
            to version. Thus, code using any attributes that have changed
            or were removed will produce compile time errors. That is useful
            and by design so that any changes in LLVM naming will break at
            compile time instead of at runtime.</para>
            </remarks>
        </member>
        <member name="T:Llvm.NET.Values.FunctionIndexKinds">
            <summary>Enumeration flags to indicate which attribute set index an attribute may apply to</summary>
        </member>
        <member name="F:Llvm.NET.Values.FunctionIndexKinds.None">
            <summary>Invalid attributes don't apply to any index</summary>
        </member>
        <member name="F:Llvm.NET.Values.FunctionIndexKinds.Function">
            <summary>The attribute is applicable to a function</summary>
        </member>
        <member name="F:Llvm.NET.Values.FunctionIndexKinds.Return">
            <summary>The attribute is applicable to a function's return</summary>
        </member>
        <member name="F:Llvm.NET.Values.FunctionIndexKinds.Parameter">
            <summary>The attribute is applicable to a function's parameter</summary>
        </member>
        <member name="T:Llvm.NET.Values.AttributeKindExtensions">
            <summary>Utility class to provide extension methods for validating usage of attribute kinds</summary>
        </member>
        <member name="T:Llvm.NET.Values.AttributeValue">
            <summary>Single attribute for functions, function returns and function parameters</summary>
            <remarks>
            This is the equivalent to the underlying llvm::AttributeImpl class. The name was changed to
            AttributeValue in .NET to prevent confusion with the standard <see cref="T:System.Attribute"/> class
            that is used throughout .NET libraries.
            </remarks>
        </member>
        <member name="P:Llvm.NET.Values.AttributeValue.Kind">
            <summary>Kind of the attribute, <see cref="F:Llvm.NET.Values.AttributeKind.None"/> for target specific named attributes</summary>
        </member>
        <member name="P:Llvm.NET.Values.AttributeValue.Name">
            <summary>Name of a named attribute or null for other kinds of attributes</summary>
        </member>
        <member name="P:Llvm.NET.Values.AttributeValue.StringValue">
            <summary>StringValue for named attributes with values</summary>
        </member>
        <member name="P:Llvm.NET.Values.AttributeValue.IntegerValue">
            <summary>Integer value of the attribute or null if the attribute doesn't have a value</summary>
        </member>
        <member name="P:Llvm.NET.Values.AttributeValue.IsString">
            <summary>Flag to indicate if this attribute is a target specific string value</summary>
        </member>
        <member name="P:Llvm.NET.Values.AttributeValue.IsInt">
            <summary>Flag to indicate if this attribute has an integer attribute</summary>
        </member>
        <member name="P:Llvm.NET.Values.AttributeValue.IsEnum">
            <summary>Flag to indicate if this attribute is a simple enumeration value</summary>
        </member>
        <member name="M:Llvm.NET.Values.AttributeValueMixins.ToAttributeValue(Llvm.NET.Values.AttributeKind,Llvm.NET.Context)">
            <summary>Implicitly cast an <see cref="T:Llvm.NET.Values.AttributeKind"/> to an <see cref="T:Llvm.NET.Values.AttributeValue"/></summary>
            <param name="kind">Kind of attribute to create</param>
            <param name="ctx">Context that should own the attribute value</param>
        </member>
        <member name="M:Llvm.NET.Values.AttributeValueMixins.ToAttributeValue(System.String,Llvm.NET.Context)">
            <summary>Implicitly cast a string to an named <see cref="T:Llvm.NET.Values.AttributeValue"/></summary>
            <param name="kind">Attribute name</param>
            <param name="ctx">Context that should own the attribute value</param>
        </member>
        <member name="T:Llvm.NET.Values.BasicBlock">
            <summary>Provides access to an LLVM Basic block</summary>
            <remarks>
            A basic block is a sequence of instructions with a single entry
            and a single exit. The exit point must be a <see cref="P:Llvm.NET.Values.BasicBlock.Terminator"/>
            instruction or the block is not (yet) well-formed.
            </remarks>
        </member>
        <member name="P:Llvm.NET.Values.BasicBlock.ContainingFunction">
            <summary>Gets the function containing the block</summary>
        </member>
        <member name="P:Llvm.NET.Values.BasicBlock.FirstInstruction">
            <summary>First instruction in the block</summary>
        </member>
        <member name="P:Llvm.NET.Values.BasicBlock.LastInstruction">
            <summary>Last instruction in the block</summary>
        </member>
        <member name="P:Llvm.NET.Values.BasicBlock.Terminator">
            <summary>Terminator instruction for the block</summary>
            <remarks>May be null if the block is not yet well-formed
             as is commonly the case while generating code for a new block
            </remarks>
        </member>
        <member name="P:Llvm.NET.Values.BasicBlock.Instructions">
            <summary>Enumerable collection of all instructions in the block</summary>
        </member>
        <member name="M:Llvm.NET.Values.BasicBlock.GetNextInstruction(Llvm.NET.Instructions.Instruction)">
            <summary>Gets the instruction that follows a given instruction in a block</summary>
            <param name="instruction">instruction in the block to get the next instruction from</param>
            <returns>Next instruction or null if none</returns>
            <exception cref="T:System.ArgumentException">Thrown when <paramref cref="T:Llvm.NET.Instructions.Instruction"/> is from a different block</exception>
        </member>
        <member name="T:Llvm.NET.Values.Constant">
            <summary>Contains an LLVM Constant value</summary>
        </member>
        <member name="P:Llvm.NET.Values.Constant.IsZeroValue">
            <summary>Indicates if the constant is a Zero value for the its type</summary>
        </member>
        <member name="M:Llvm.NET.Values.Constant.NullValueFor(Llvm.NET.Types.ITypeRef)">
            <summary>Create a NULL pointer for a given type</summary>
            <param name="typeRef">Type of pointer to create a null vale for</param>
            <returns>Constant NULL pointer of the specified type</returns>
        </member>
        <member name="M:Llvm.NET.Values.Constant.AllOnesValueFor(Llvm.NET.Types.ITypeRef)">
            <summary>Creates a constant instance of <paramref name="typeRef"/> with all bits in the instance set to 1</summary>
            <param name="typeRef">Type of value to create</param>
            <returns>Constant for the type with all instance bits set to 1</returns>
        </member>
        <member name="M:Llvm.NET.Values.Constant.UndefinedValueFor(Llvm.NET.Types.ITypeRef)">
            <summary>Creates an <see cref="T:Llvm.NET.Values.Constant"/> representing an undefined value for <paramref name="typeRef"/></summary>
            <param name="typeRef">Type to create the undefined value for</param>
            <returns>
            <see cref="T:Llvm.NET.Values.Constant"/> representing an undefined value of <paramref name="typeRef"/>
            </returns>
        </member>
        <member name="M:Llvm.NET.Values.Constant.ConstPointerToNullFor(Llvm.NET.Types.ITypeRef)">
            <summary>Create a constant NULL pointer for a given type</summary>
            <param name="typeRef">Type of pointer to create a null value for</param>
            <returns>Constant NULL pointer of the specified type</returns>
        </member>
        <member name="T:Llvm.NET.Values.ConstantArray">
            <summary>LLVM Constant Array</summary>
            <remarks>
            Due to how LLVM treats constant arrays internally creating a constant array
            with the From method overloads may not actually produce a ConstantArray
            instance. At the least it will produce a Constant. LLVM will determine the
            appropriate internal representation based on the input types and values
            </remarks>
        </member>
        <member name="M:Llvm.NET.Values.ConstantArray.From(Llvm.NET.Types.ITypeRef,Llvm.NET.Values.Constant[])">
            <summary>Create a constant array of values of a given type</summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="values">Values to initialize the array</param>
            <returns>Constant representing the array</returns>
        </member>
        <member name="M:Llvm.NET.Values.ConstantArray.From(Llvm.NET.Types.ITypeRef,System.Int32,Llvm.NET.Values.Constant[])">
            <summary>Create a constant array of values of a given type with a fixed size, zero filling any un-specified values</summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="len">Length of the array</param>
            <param name="values">Values to initialize the array</param>
            <returns>Constant representing the array</returns>
            <remarks>
            If the number of arguments provided for the values is less than <paramref name="len"/>
            then the remaining elements of the array are set with the null value for the <paramref name="elementType"/>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Values.ConstantArray.From(Llvm.NET.Types.ITypeRef,System.Collections.Generic.IList{Llvm.NET.Values.Constant})">
            <summary>Create a constant array of values of a given type</summary>
            <param name="elementType">Type of elements in the array</param>
            <param name="values">Values to initialize the array</param>
            <returns>Constant representing the array</returns>
        </member>
        <member name="T:Llvm.NET.Values.ConstantDataSequential">
            <summary>
            A vector or array constant whose element type is a simple 1/2/4/8-byte integer
            or float/double, and whose elements are just  simple data values
            (i.e. ConstantInt/ConstantFP).
            </summary>
            <remarks>
            This Constant node has no operands because
            it stores all of the elements of the constant as densely packed data, instead
            of as <see cref="T:Llvm.NET.Values.Value"/>s
            </remarks>
        </member>
        <member name="T:Llvm.NET.Values.ConstantExpression">
            <summary>While technically a type in LLVM, ConstantExpression is primarily a static factory for Constants</summary>
        </member>
        <member name="T:Llvm.NET.Values.ConstantFP">
            <summary>Floating point constant value in LLVM</summary>
        </member>
        <member name="T:Llvm.NET.Values.ConstantInt">
            <summary>Represents an arbitrary bit width integer constant in LLVM</summary>
            <remarks>
            Note - for integers, in LLVM, signed or unsigned is not part of the type of
            the integer. The distinction between them is determined entirely by the
            instructions used on the integer values.
            </remarks>
        </member>
        <member name="P:Llvm.NET.Values.ConstantInt.ZeroExtendedValue">
            <summary>Retrieves the value of the constant zero extended to 64 bits</summary>
        </member>
        <member name="P:Llvm.NET.Values.ConstantInt.SignExtendedValue">
            <summary>Sign extends the value to a 64 bit value</summary>
        </member>
        <member name="M:Llvm.NET.Values.ConstantPointerNull.From(Llvm.NET.Types.ITypeRef)">
            <summary>Creates a constant null pointer to a given type</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Llvm.NET.Values.Function">
            <summary>LLVM Function definition</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.Signature">
            <summary>Signature type of the function</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.EntryBlock">
            <summary>Entry block for this function</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.BasicBlocks">
            <summary>Basic Blocks for the function</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.Parameters">
            <summary>Parameters for the function including any method definition specific attributes (i.e. ByVal)</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.CallingConvention">
            <summary>Calling convention for the method</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.IntrinsicId">
            <summary>LLVM instrinsicID for the method</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.IsVarArg">
            <summary>Flag to indicate if the method signature accepts variable arguments</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.ReturnType">
            <summary>Return type of the function</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.DISubProgram">
            <summary>Debug information for this function</summary>
        </member>
        <member name="P:Llvm.NET.Values.Function.GcName">
            <summary>Garbage collection engine name that this function is generated to work with</summary>
            <remarks>For details on GC support in LLVM see: http://llvm.org/docs/GarbageCollection.html </remarks>
        </member>
        <member name="M:Llvm.NET.Values.Function.Verify">
            <summary>Verifies the function is valid and all blocks properly terminated</summary>
        </member>
        <member name="M:Llvm.NET.Values.Function.PrependBasicBlock(System.String)">
            <summary>Add a new basic block to the beginning of a function</summary>
            <param name="name">Name (label) for the block</param>
            <returns><see cref="T:Llvm.NET.Values.BasicBlock"/> created and inserted at the beginning of the function</returns>
        </member>
        <member name="M:Llvm.NET.Values.Function.AppendBasicBlock(System.String)">
            <summary>Appends a new basic block to a function</summary>
            <param name="name">Name (label) of the block</param>
            <returns><see cref="T:Llvm.NET.Values.BasicBlock"/> created and inserted onto the end of the function</returns>
        </member>
        <member name="M:Llvm.NET.Values.Function.FindOrCreateNamedBlock(System.String)">
            <summary>Retrieves or creates  block by name</summary>
            <param name="name">Block name (label) to look for or create</param>
            <returns><see cref="T:Llvm.NET.Values.BasicBlock"/> If the block was created it is appended to the end of function</returns>
            <remarks>
            This method tries to find a block by it's name and returns it if found, if not found a new block is
            created and appended to the current function.
            </remarks>
        </member>
        <member name="T:Llvm.NET.Values.GlobalAlias">
            <summary>LLVM Global Alias for a function or global value</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalObject.Alignment">
            <summary>Alignment requirements for this object</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalObject.Section">
            <summary>Linker section this object belongs to</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalObject.Comdat">
            <summary>Gets or sets the comdat attached to this object, if any</summary>
            <remarks>
            Setting this property to <see langword="null"/> or an
            empty string will remove any comdat setting for the
            global object.
            </remarks>
        </member>
        <member name="T:Llvm.NET.Values.GlobalObjectExtensions">
            <summary>Fluent style extensions for properties of <see cref="T:Llvm.NET.Values.GlobalObject"/></summary>
        </member>
        <member name="T:Llvm.NET.Values.GlobalValue">
            <summary>LLVM Global value </summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalValue.Visibility">
            <summary>Visibility of this global value</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalValue.Linkage">
            <summary>Linkage specification for this symbol</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalValue.UnnamedAddress">
            <summary>Flag to indicate if this is an Unnamed address</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalValue.IsDeclaration">
            <summary>Flag to indicate if this is a declaration</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalValue.ParentModule">
            <summary>Module containing this global value</summary>
        </member>
        <member name="T:Llvm.NET.Values.GlobalValueExtensions">
            <summary>Fluent style extensions for modifying properties of a <see cref="T:Llvm.NET.Values.GlobalValue"/></summary>
        </member>
        <member name="M:Llvm.NET.Values.GlobalValueExtensions.Visibility``1(``0,Llvm.NET.Visibility)">
            <summary>Visibility of this global value</summary>
        </member>
        <member name="M:Llvm.NET.Values.GlobalValueExtensions.Linkage``1(``0,Llvm.NET.Linkage)">
            <summary>Linkage specification for this symbol</summary>
        </member>
        <member name="T:Llvm.NET.Values.GlobalVariable">
            <summary>An LLVM Global Variable</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalVariable.IsExternallyInitialized">
            <summary>Flag to indicate if this variable is initialized in an external module</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalVariable.IsConstant">
            <summary>Gets or sets if this global is a Constant</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalVariable.IsThreadLocal">
            <summary>Flag to indicate if this global is stored per thread</summary>
        </member>
        <member name="P:Llvm.NET.Values.GlobalVariable.Initializer">
            <summary>Initial value for the variable</summary>
        </member>
        <member name="M:Llvm.NET.Values.GlobalVariable.RemoveFromParent">
            <summary>Removes the value from its parent module, but does not delete it</summary>
        </member>
        <member name="T:Llvm.NET.Values.FunctionParameterList">
            <summary>Support class to provide read only list semantics to the parameters of a method</summary>
        </member>
        <member name="T:Llvm.NET.Values.IAttributeDictionary">
            <summary>Interface to an Attribute Dictionary</summary>
            <remarks>
            <para>This interface provides a full collection of all the
            attributes keyed by the <see cref="T:Llvm.NET.FunctionAttributeIndex"/>
            </para>
            <note>This connceptually corresponds to the functionality of the
            LLVM AttributeSet class for Versions prior to 5. (at this
            time v5 is not yet released). In 5 the equivalent type is
            currently AttributeList. In v5 AttributeSet has no index and
            is therefore more properly a set than in the past. To help
            remove confusion and satisfy naming rules this is called
            a Dictionary as that reflects the use here and fits the
            direction of LLVM</note>
            </remarks>
        </member>
        <member name="T:Llvm.NET.Values.Use">
            <summary>LLVM Use, which is essentially a tuple of the <see cref="P:Llvm.NET.Values.Use.User"/> and the <see cref="P:Llvm.NET.Values.Use.Value"/> used</summary>
            <remarks>
            A Use in LLVM forms a link in a directed graph of dependencies for values.
            </remarks>
        </member>
        <member name="T:Llvm.NET.Values.User">
            <summary>Contains an LLVM User value</summary>
            <remarks>
            A user is one role in the user->uses relationship
            conveyed by the LLVM value model. A User can contain
            references (e.g. uses) of other values.
            </remarks>
        </member>
        <member name="P:Llvm.NET.Values.User.Operands">
            <summary>Collection of operands</summary>
        </member>
        <member name="P:Llvm.NET.Values.User.Uses">
            <summary>Enumerable collection of <see cref="T:Llvm.NET.Values.Use"/>s</summary>
        </member>
        <member name="T:Llvm.NET.Values.UserOperandList">
            <summary>Support class to provide read-only list semantics to the operands of a <see cref="T:Llvm.NET.Values.User"/> of a method</summary>
        </member>
        <member name="T:Llvm.NET.Values.Value">
            <summary>LLVM Value</summary>
            <remarks>
            Value is the root of a hierarchy of types representing values
            in LLVM. Values (and derived classes) are never constructed
            directly with the new operator. Instead, they are produced by
            other classes in this library internally. This is because they
            are just wrappers around the LLVM-C API handles and must
            maintain the "uniqueing" semantics. (e.g. allowing reference
            equality for values that are fundamentally the same value)
            This is generally hidden in the internals of the Llvm.NET
            library so callers need not be concerned with the details
            but can rely on the expected behavior that two Value instances
            referring to the same actual value (i.e. a function) are actually
            the same .NET object as well within the same <see cref="P:Llvm.NET.Values.Value.Context"/>
            </remarks>
        </member>
        <member name="P:Llvm.NET.Values.Value.Name">
            <summary>Gets or sets name of the value (if any)</summary>
        </member>
        <member name="P:Llvm.NET.Values.Value.IsUndefined">
            <summary>Gets a value indicating whether this value is Undefined</summary>
        </member>
        <member name="P:Llvm.NET.Values.Value.IsNull">
            <summary>Gets a value indicating whether the Value represents the NULL value for the values type</summary>
        </member>
        <member name="P:Llvm.NET.Values.Value.NativeType">
            <summary>Gets the type of the value</summary>
        </member>
        <member name="M:Llvm.NET.Values.Value.ToString">
            <summary>Generates a string representing the LLVM syntax of the value</summary>
            <returns>string version of the value formatted by LLVM</returns>
        </member>
        <member name="M:Llvm.NET.Values.Value.ReplaceAllUsesWith(Llvm.NET.Values.Value)">
            <summary>Replace all uses of a <see cref="T:Llvm.NET.Values.Value"/> with another one</summary>
            <param name="other">New value</param>
        </member>
        <member name="M:Llvm.NET.Values.Value.TryGetExtendedPropertyValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Llvm.NET.Values.Value.AddExtendedPropertyValue(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Llvm.NET.Values.Value.FromHandle(Llvm.NET.Native.LLVMValueRef)">
            <summary>Gets an Llvm.NET managed wrapper for a LibLLVM value handle</summary>
            <param name="valueRef">Value handle to wrap</param>
            <returns>LLVM.NET managed instance for the handle</returns>
            <remarks>
            This method uses a cached mapping to ensure that two calls given the same
            input handle returns the same managed instance so that reference equality
            works as expected.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Values.Value.FromHandle``1(Llvm.NET.Native.LLVMValueRef)">
            <summary>Gets an Llvm.NET managed wrapper for a LibLLVM value handle</summary>
            <typeparam name="T">Required type for the handle</typeparam>
            <param name="valueRef">Value handle to wrap</param>
            <returns>LLVM.NET managed instance for the handle</returns>
            <remarks>
            This method uses a cached mapping to ensure that two calls given the same
            input handle returns the same managed instance so that reference equality
            works as expected.
            </remarks>
            <exception cref="T:System.InvalidCastException">When the handle is for a different type of handle than specified by <typeparamref name="T"/></exception>
        </member>
        <member name="M:Llvm.NET.Values.Value.StaticFactory(Llvm.NET.Native.LLVMValueRef)">
            <summary>Central factory for creating instances of <see cref="T:Llvm.NET.Values.Value"/> and all derived types</summary>
            <param name="h">LibLLVM handle for the value</param>
            <returns>New Value or derived type instance that wraps the underlying LibLLVM handle</returns>
            <remarks>
            This method will determine the correct type for the handle and construct an instance of that
            type wrapping the handle.
            </remarks>
        </member>
        <member name="T:Llvm.NET.Values.ValueExtensions">
            <summary>Provides extension methods to <see cref="T:Llvm.NET.Values.Value"/> that cannot be achieved as members of the class</summary>
            <remarks>
            Using generic static extension methods allows for fluent coding while retaining the type of the "this" parameter.
            If these were members of the <see cref="T:Llvm.NET.Values.Value"/> class then the only return type could be <see cref="T:Llvm.NET.Values.Value"/>,
            thus losing the original type and requiring a cast to get back to it.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Values.ValueExtensions.SetDebugLocation``1(``0,Llvm.NET.DebugInfo.DILocation)">
            <summary>Sets the debugging location for a value</summary>
            <typeparam name="T"> Type of the value to tag</typeparam>
            <param name="value">Value to set debug location for</param>
            <param name="location">Debug location information</param>
            <remarks>
            <para>Technically speaking only an <see cref="T:Llvm.NET.Instructions.Instruction"/> can have debug location
            information. However, since LLVM will perform constant folding in the <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/>
            most of the methods in <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/> return a <see cref="T:Llvm.NET.Values.Value"/> rather than a
            more specific <see cref="T:Llvm.NET.Instructions.Instruction"/>. Thus, without this extension method here,
            code would need to know ahead of time that an actual instruction would be produced then cast the result
            to an <see cref="T:Llvm.NET.Instructions.Instruction"/> and then set the debug location. This makes the code rather
            ugly and tedious to manage. Placing this as a generic extension method ensures that the return type matches
            the original and no additional casting is needed, which would defeat the purpose of doing this. For
            <see cref="T:Llvm.NET.Values.Value"/> types that are not instructions this does nothing. This allows for a simpler fluent
            style of programming where the actual type is retained even in cases where an <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/>
            method will always return an actual instruction.</para>
            <para>In order to help simplify code generation for cases where not all of the source information is
            available this is a NOP if <paramref name="location"/> is null. Thus, it is safe to call even when debugging
            information isn't actually available. This helps to avoid cluttering calling code with test for debug info
            before trying to add it.</para>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Values.ValueExtensions.SetDebugLocation``1(``0,System.UInt32,System.UInt32,Llvm.NET.DebugInfo.DILocalScope)">
            <summary>Sets the debugging location for a value</summary>
            <typeparam name="T"> Type of the value to tag</typeparam>
            <param name="value">Value to set debug location for</param>
            <param name="line">Line number</param>
            <param name="column">Column number</param>
            <param name="scope">Scope for the value</param>
            <remarks>
            <para>Technically speaking only an <see cref="T:Llvm.NET.Instructions.Instruction"/> can have debug location
            information. However, since LLVM will perform constant folding in the <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/>
            most of the methods in <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/> return a <see cref="T:Llvm.NET.Values.Value"/> rather than a
            more specific <see cref="T:Llvm.NET.Instructions.Instruction"/>. Thus, without this extension method here,
            code would need to know ahead of time that an actual instruction would be produced then cast the result
            to an <see cref="T:Llvm.NET.Instructions.Instruction"/> and then set the debug location. This makes the code rather
            ugly and tedious to manage. Placing this as a generic extension method ensures that the return type matches
            the original and no additional casting is needed, which would defeat the purpose of doing this. For
            <see cref="T:Llvm.NET.Values.Value"/> types that are not instructions this does nothing. This allows for a simpler fluent
            style of programming where the actual type is retained even in cases where an <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/>
            method will always return an actual instruction.</para>
            <para>In order to help simplify code generation for cases where not all of the source information is
            available this is a NOP if <paramref name="scope"/> is null. Thus, it is safe to call even when debugging
            information isn't actually available. This helps to avoid cluttering calling code with test for debug info
            before trying to add it.</para>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Values.ValueExtensions.RegisterName``1(``0,System.String)">
            <summary>Sets the virtual register name for a value</summary>
            <typeparam name="T"> Type of the value to set the name for</typeparam>
            <param name="value">Value to set register name for</param>
            <param name="name">Name for the virtual register the value represents</param>
            <remarks>
            <para>Technically speaking only an <see cref="T:Llvm.NET.Instructions.Instruction"/> can have register name
            information. However, since LLVM will perform constant folding in the <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/>
            it almost all of the methods in <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/> return a <see cref="T:Llvm.NET.Values.Value"/> rather
            than an more specific <see cref="T:Llvm.NET.Instructions.Instruction"/>. Thus, without this extension method here,
            code would need to know ahead of time that an actual instruction would be produced then cast the result
            to an <see cref="T:Llvm.NET.Instructions.Instruction"/> and then set the debug location. This makes the code rather
            ugly and tedious to manage. Placing this as a generic extension method ensures that the return type matches
            the original and no additional casting is needed, which would defeat the purpose of doing this. For
             <see cref="T:Llvm.NET.Values.Value"/> types that are not instructions this does nothing. This allows for a simpler fluent
            style of programming where the actual type is retained even in cases where an <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/>
            method will always return an actual instruction.</para>
            <para>Since the <see cref="P:Llvm.NET.Values.Value.Name"/> property is available on all <see cref="T:Llvm.NET.Values.Value"/>s this is slightly
            redundant. It is useful for maintaining the fluent style of coding along with expressing intent more clearly.
            (e.g. using this makes it expressly clear that the intent is to set the virtual register name and not the
            name of a local variable etc...) Using the fluent style allows a significant reduction in the number of
            overloaded methods in <see cref="T:Llvm.NET.Instructions.InstructionBuilder"/> to account for all variations with or without a name.
            </para>
            </remarks>
        </member>
        <member name="T:Llvm.NET.Context">
            <summary>Encapsulates an LLVM context</summary>
            <remarks>
            <para>A context in LLVM is a container for interning (LLVM refers
            to this as "uniqueing") various types and values in the system. This
            allows running multiple LLVM tool transforms etc.. on different threads
            without causing them to collide namespaces and types even if they use
            the same name (e.g. module one may have a type Foo, and so does module
            two but they are completely distinct from each other)
            </para>
            <para>LLVM Debug information is ultimately all parented to a top level
            <see cref="T:Llvm.NET.DebugInfo.DICompileUnit"/> as the scope, and a compilation
            unit is bound to a <see cref="T:Llvm.NET.NativeModule"/>, even though, technically
            the types are owned by a Context. Thus to keep things simpler and help
            make working with debug information easier. Lllvm.NET encapsulates the
            native type and the debug type in separate classes that are instances
            of the <see cref="T:Llvm.NET.DebugInfo.IDebugType`2"/> interface </para>
            <note type="note">It is important to be aware of the fact that a Context
            is not thread safe. The context itself and the object instances it owns
            are intended for use by a single thread only. Accessing and manipulating
            LLVM objects from multiple threads may lead to race conditions corrupted
            state and any number of other undefined issues.</note>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.#ctor">
            <summary>Creates a new context</summary>
        </member>
        <member name="P:Llvm.NET.Context.IsDisposed">
            <summary>Flag to indicate if this instance is still valid</summary>
        </member>
        <member name="P:Llvm.NET.Context.VoidType">
            <summary>Get's the LLVM void type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.BoolType">
            <summary>Get's the LLVM boolean type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.Int8Type">
            <summary>Get's the LLVM 8 bit integer type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.Int16Type">
            <summary>Get's the LLVM 16 bit integer type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.Int32Type">
            <summary>Get's the LLVM 32 bit integer type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.Int64Type">
            <summary>Get's the LLVM 64 bit integer type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.HalfFloatType">
            <summary>Get's the LLVM half precision floating point type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.FloatType">
            <summary>Get's the LLVM single precision floating point type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.DoubleType">
            <summary>Get's the LLVM double precision floating point type for this context</summary>
        </member>
        <member name="P:Llvm.NET.Context.Metadata">
            <summary>Gets an enumerable collection of all the metadata created in this context</summary>
        </member>
        <member name="M:Llvm.NET.Context.GetPointerTypeFor(Llvm.NET.Types.ITypeRef)">
            <summary>Get a type that is a pointer to a value of a given type</summary>
            <param name="elementType">Type of value the pointer points to</param>
            <returns><see cref="T:Llvm.NET.Types.IPointerType"/> for a pointer that references a value of type <paramref name="elementType"/></returns>
        </member>
        <member name="M:Llvm.NET.Context.GetIntType(System.UInt32)">
            <summary>Get's an LLVM integer type of arbitrary bit width</summary>
            <remarks>
            For standard integer bit widths (e.g. 1,8,16,32,64) this will return
            the same type as the corresponding specialized property.
            (e.g. GetIntType(1) is the same as <see cref="P:Llvm.NET.Context.BoolType"/>,
             GetIntType(16) is the same as <see cref="P:Llvm.NET.Context.Int16Type"/>, etc... )
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.GetFunctionType(Llvm.NET.Types.ITypeRef,Llvm.NET.Types.ITypeRef[])">
            <summary>Get an LLVM Function type (e.g. signature)</summary>
            <param name="returnType">Return type of the function</param>
            <param name="args">Optional set of function argument types</param>
            <returns>Signature type for the specified signature</returns>
        </member>
        <member name="M:Llvm.NET.Context.GetFunctionType(Llvm.NET.Types.ITypeRef,System.Collections.Generic.IEnumerable{Llvm.NET.Types.ITypeRef})">
            <summary>Get an LLVM Function type (e.g. signature)</summary>
            <param name="returnType">Return type of the function</param>
            <param name="args">Potentially empty set of function argument types</param>
            <returns>Signature type for the specified signature</returns>
        </member>
        <member name="M:Llvm.NET.Context.GetFunctionType(Llvm.NET.Types.ITypeRef,System.Collections.Generic.IEnumerable{Llvm.NET.Types.ITypeRef},System.Boolean)">
            <summary>Get an LLVM Function type (e.g. signature)</summary>
            <param name="returnType">Return type of the function</param>
            <param name="args">Potentially empty set of function argument types</param>
            <param name="isVarArgs">Flag to indicate if the method supports C/C++ style VarArgs</param>
            <returns>Signature type for the specified signature</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}[])">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}})">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,System.Boolean,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}[])">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="isVarArg">Flag to indicate if this function is variadic</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateFunctionType(Llvm.NET.DebugInfo.DebugInfoBuilder,System.Boolean,Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType},System.Collections.Generic.IEnumerable{Llvm.NET.DebugInfo.IDebugType{Llvm.NET.Types.ITypeRef,Llvm.NET.DebugInfo.DIType}})">
            <summary>Creates a FunctionType with Debug information</summary>
            <param name="diBuilder"><see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder"/>to use to create the debug information</param>
            <param name="isVarArg">Flag to indicate if this function is variadic</param>
            <param name="retType">Return type of the function</param>
            <param name="argTypes">Argument types of the function</param>
            <returns>Function signature</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstantStruct(System.Boolean,Llvm.NET.Values.Constant[])">
            <summary>Creates a constant structure from a set of values</summary>
            <param name="packed">Flag to indicate if the structure is packed and no alignment should be applied to the members</param>
            <param name="values">Set of values to use in forming the structure</param>
            <returns>Newly created <see cref="T:Llvm.NET.Values.Constant"/></returns>
            <remarks>
            <note type="note">The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Llvm.NET.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstantStruct(System.Boolean,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Constant})">
            <summary>Creates a constant structure from a set of values</summary>
            <param name="values">Set of values to use in forming the structure</param>
            <param name="packed">Flag to indicate if the structure is packed and no alignment should be applied to the members</param>
            <returns>Newly created <see cref="T:Llvm.NET.Values.Constant"/></returns>
            <remarks>
            <note type="note">The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Llvm.NET.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateNamedConstantStruct(Llvm.NET.Types.IStructType,Llvm.NET.Values.Constant[])">
            <summary>Creates a constant instance of a specified structure type from a set of values</summary>
            <param name="type">Type of the structure to create</param>
            <param name="values">Set of values to use in forming the structure</param>
            <returns>Newly created <see cref="T:Llvm.NET.Values.Constant"/></returns>
            <remarks>
            <note type="note">The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Llvm.NET.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateNamedConstantStruct(Llvm.NET.Types.IStructType,System.Collections.Generic.IEnumerable{Llvm.NET.Values.Constant})">
            <summary>Creates a constant instance of a specified structure type from a set of values</summary>
            <param name="type">Type of the structure to create</param>
            <param name="values">Set of values to use in forming the structure</param>
            <returns>Newly created <see cref="T:Llvm.NET.Values.Constant"/></returns>
            <remarks>
            <note type="note">The actual concrete return type depends on the parameters provided and will be one of the following:
            <list type="table">
            <listheader>
            <term><see cref="T:Llvm.NET.Values.Constant"/> derived type</term><description>Description</description>
            </listheader>
            <item><term>ConstantAggregateZero</term><description>If all the member values are zero constants</description></item>
            <item><term>UndefValue</term><description>If all the member values are UndefValue</description></item>
            <item><term>ConstantStruct</term><description>All other cases</description></item>
            </list>
            </note>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateStructType(System.String)">
            <summary>Create an empty structure type</summary>
            <param name="name">Name of the type</param>
            <returns>New type</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateStructType(System.Boolean,Llvm.NET.Types.ITypeRef,Llvm.NET.Types.ITypeRef[])">
            <summary>Create an anonymous structure type (e.g. Tuple)</summary>
            <param name="packed">Flag to indicate if the structure is "packed"</param>
            <param name="element0">Type of the first field of the structure</param>
            <param name="elements">Types of any additional fields of the structure</param>
            <returns>
            <see cref="T:Llvm.NET.Types.IStructType"/> with the specified body defined.
            </returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateStructType(System.String,System.Boolean,Llvm.NET.Types.ITypeRef[])">
            <summary>Creates a new structure type in this <see cref="T:Llvm.NET.Context"/></summary>
            <param name="name">Name of the structure</param>
            <param name="packed">Flag indicating if the structure is packed</param>
            <param name="elements">Types for the structures elements in layout order</param>
            <returns>
            <see cref="T:Llvm.NET.Types.IStructType"/> with the specified body defined.
            </returns>
            <remarks>
            If the elements argument list is empty then an opaque type is created (e.g. a forward reference)
            The <see cref="M:Llvm.NET.Types.IStructType.SetBody(System.Boolean,Llvm.NET.Types.ITypeRef[])"/> method provides a means to add a body to
            an opaque type at a later time if the details of the body are required. (If only pointers to
            to the type are required the body isn't required)
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateMetadataString(System.String)">
            <summary>Creates a metadata string from the given string</summary>
            <param name="value">string to create as metadata</param>
            <returns>new metadata string</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstantString(System.String)">
            <summary>Create a constant data string value</summary>
            <param name="value">string to convert into an LLVM constant value</param>
            <returns>new <see cref="T:Llvm.NET.Values.ConstantDataArray"/></returns>
            <remarks>
            This converts th string to ANSI form and creates an LLVM constant array of i8
            characters for the data without any terminating null character.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstantString(System.String,System.Boolean)">
            <summary>Create a constant data string value</summary>
            <param name="value">string to convert into an LLVM constant value</param>
            <param name="nullTerminate">flag to indicate if the string should include a null terminator</param>
            <returns>new <see cref="T:Llvm.NET.Values.ConstantDataArray"/></returns>
            <remarks>
            This converts the string to ANSI form and creates an LLVM constant array of i8
            characters for the data without any terminating null character.
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.Boolean)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 1</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.Byte)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 8</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.SByte)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 8</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.Int16)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 16</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.UInt16)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 16</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.Int32)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 32</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.UInt32)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 32</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.Int64)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 64</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.UInt64)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 64</summary>
            <param name="constValue">Value for the constant</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.UInt32,System.UInt64,System.Boolean)">
            <summary>Creates a new <see cref="T:Llvm.NET.Values.ConstantInt"/> with a bit length of 64</summary>
            <param name="bitWidth">Bit width of the integer</param>
            <param name="constValue">Value for the constant</param>
            <param name="signExtend">flag to indicate if the const value should be sign extended</param>
            <returns><see cref="T:Llvm.NET.Values.ConstantInt"/> representing the value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(Llvm.NET.Types.ITypeRef,System.UInt64,System.Boolean)">
            <summary>Create a constant value of the specified integer type</summary>
            <param name="intType">Integer type</param>
            <param name="constValue">value</param>
            <param name="signExtend">flag to indicate if <paramref name="constValue"/> is sign extended</param>
            <returns>Constant for the specified value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.Single)">
            <summary>Creates a constant floating point value for a given value</summary>
            <param name="constValue">Value to make into a <see cref="T:Llvm.NET.Values.ConstantFP"/></param>
            <returns>Constant value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateConstant(System.Double)">
            <summary>Creates a constant floating point value for a given value</summary>
            <param name="constValue">Value to make into a <see cref="T:Llvm.NET.Values.ConstantFP"/></param>
            <returns>Constant value</returns>
        </member>
        <member name="M:Llvm.NET.Context.CreateAttribute(Llvm.NET.Values.AttributeKind)">
            <summary>Creates a simple boolean attribute</summary>
            <param name="kind">Kind of attribute</param>
        </member>
        <member name="M:Llvm.NET.Context.CreateAttribute(Llvm.NET.Values.AttributeKind,System.UInt64)">
            <summary>Creates an attribute with an integer value parameter</summary>
            <param name="kind">The kind of attribute</param>
            <param name="value">Value for the attribute</param>
            <remarks>
            <para>Not all attributes support a value and those that do don't all support
            a full 64bit value. The following table provides the kinds of attributes
            accepting a value and the allowed size of the values.</para>
            <list type="table">
            <listheader><term><see cref="T:Llvm.NET.Values.AttributeKind"/></term><term>Bit Length</term></listheader>
            <item><term><see cref="F:Llvm.NET.Values.AttributeKind.Alignment"/></term><term>32</term></item>
            <item><term><see cref="F:Llvm.NET.Values.AttributeKind.StackAlignment"/></term><term>32</term></item>
            <item><term><see cref="F:Llvm.NET.Values.AttributeKind.Dereferenceable"/></term><term>64</term></item>
            <item><term><see cref="F:Llvm.NET.Values.AttributeKind.DereferenceableOrNull"/></term><term>64</term></item>
            </list>
            </remarks>
        </member>
        <member name="M:Llvm.NET.Context.CreateAttribute(System.String)">
            <summary>Adds a valueless named attribute</summary>
            <param name="name">Attribute name</param>
        </member>
        <member name="M:Llvm.NET.Context.CreateAttribute(System.String,System.String)">
            <summary>Adds a Target specific named attribute with value</summary>
            <param name="name">Name of the attribute</param>
            <param name="value">Value of the attribute</param>
        </member>
        <member name="T:Llvm.NET.ModuleFlagBehavior">
            <summary>Enumeration to indicate the behavior of module level flags metadata sharing the same name in a <see cref="T:Llvm.NET.NativeModule"/></summary>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.Invalid">
            <summary>Invalid value (default value for this enumeration)</summary>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.Error">
            <summary>Emits an error if two values disagree, otherwise the resulting value is that of the operands</summary>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.Warning">
            <summary>Emits a warning if two values disagree. The result will be the operand for the flag from the first module being linked</summary>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.Require">
            <summary>Adds a requirement that another module flag be present and have a specified value after linking is performed</summary>
            <remarks>
            The value must be a metadata pair, where the first element of the pair is the ID of the module flag to be restricted, and the
            second element of the pair is the value the module flag should be restricted to. This behavior can be used to restrict the
            allowable results (via triggering of an error) of linking IDs with the <see cref="F:Llvm.NET.ModuleFlagBehavior.Override"/> behavior
            </remarks>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.Override">
            <summary>Uses the specified value, regardless of the behavior or value of the other module</summary>
            <remarks>If both modules specify Override, but the values differ, and error will be emitted</remarks>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.Append">
            <summary>Appends the two values, which are required to be metadata nodes</summary>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.AppendUnique">
            <summary>Appends the two values, which are required to be metadata nodes dropping duplicate entries in the second list</summary>
        </member>
        <member name="F:Llvm.NET.ModuleFlagBehavior.Max">
            <summary>Takes the max of the two values, which are required to be integers</summary>
        </member>
        <member name="T:Llvm.NET.OpCode">
            <summary>LLVM Instruction opcodes</summary>
            <remarks>
            These are based on the "C" API and therefore more stable as changes in the underlying instruction ids are remapped in the C API layer
            </remarks>
        </member>
        <member name="T:Llvm.NET.TypeKind">
            <summary>Basic kind of a type</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Void">
            <summary>Type with no size</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Float16">
            <summary>16 bit floating point type</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Float32">
            <summary>32 bit floating point type</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Float64">
            <summary>64 bit floating point type</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.X86Float80">
            <summary>80 bit floating point type (X87)</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Float128m112">
            <summary>128 bit floating point type (112-bit mantissa)</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Float128">
            <summary>128 bit floating point type (two 64-bits)</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Label">
            <summary><see cref="T:Llvm.NET.Values.BasicBlock"/> instruction label</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Integer">
            <summary>Arbitrary bit width integers</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Function">
            <summary><see cref="T:Llvm.NET.Types.IFunctionType"/></summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Struct">
            <summary><see cref="T:Llvm.NET.Types.IStructType"/></summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Array">
            <summary><see cref="T:Llvm.NET.Types.IArrayType"/></summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Pointer">
            <summary><see cref="T:Llvm.NET.Types.IPointerType"/></summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Vector">
            <summary>SIMD 'packed' format, or other <see cref="T:Llvm.NET.Types.IVectorType"/> implementation</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Metadata">
            <summary><see cref="T:Llvm.NET.LlvmMetadata"/></summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.X86MMX">
            <summary>x86 MMX data type</summary>
        </member>
        <member name="F:Llvm.NET.TypeKind.Token">
            <summary>Exception handler token</summary>
        </member>
        <member name="T:Llvm.NET.LlvmCallingConvention">
            <summary>Calling Convention for functions</summary>
        </member>
        <member name="T:Llvm.NET.Linkage">
            <summary>Linkage specification for functions and globals</summary>
        </member>
        <member name="T:Llvm.NET.Visibility">
            <summary>Enumeration for the visibility of a global value</summary>
        </member>
        <member name="T:Llvm.NET.Predicate">
            <summary>Unified predicate enumeration</summary>
            <remarks>
            Underneath the C API this is what LLVM uses. For some reason the C API
            split it into the integer and float predicate enumerations.
            </remarks>
        </member>
        <member name="F:Llvm.NET.Predicate.BadFcmpPredicate">
            <summary>Any value Greater than or equal to this is not valid for Fcmp operations</summary>
        </member>
        <member name="F:Llvm.NET.Predicate.BadIcmpPredicate">
            <summary>Any value Greater than or equal to this is not valid for Icmp operations</summary>
        </member>
        <member name="T:Llvm.NET.IntPredicate">
            <summary>Predicate enumeration for integer comparison</summary>
        </member>
        <member name="T:Llvm.NET.RealPredicate">
            <summary>Predicate enumeration for integer comparison</summary>
        </member>
        <member name="T:Llvm.NET.CodeGenOpt">
            <summary>Optimization level for target code generation</summary>
        </member>
        <member name="T:Llvm.NET.Reloc">
            <summary>Relocation type for target code generation</summary>
        </member>
        <member name="T:Llvm.NET.CodeModel">
            <summary>Code model to use for target code generation</summary>
        </member>
        <member name="T:Llvm.NET.CodeGenFileType">
            <summary>Output file type for target code generation</summary>
        </member>
        <member name="T:Llvm.NET.ByteOrdering">
            <summary>Byte ordering for target code generation and data type layout</summary>
        </member>
        <member name="T:Llvm.NET.FunctionAttributeIndex">
            <summary>Function index for attributes</summary>
            <remarks>
            Attributes on functions apply to the function itself, the return type
            or one of the function's parameters. This enumeration is used to
            identify where the attribute applies.
            </remarks>
        </member>
        <member name="F:Llvm.NET.FunctionAttributeIndex.Function">
            <summary>The attribute applies to the function itself</summary>
        </member>
        <member name="F:Llvm.NET.FunctionAttributeIndex.ReturnType">
            <summary>The attribute applies to the return type of the function</summary>
        </member>
        <member name="F:Llvm.NET.FunctionAttributeIndex.Parameter0">
            <summary>The attribute applies to the first parameter of the function</summary>
            <remarks>
            Additional parameters can identified by simply adding an integer value to
            this value. (i.e. FunctionAttributeIndex.Parameter0 + 1 )
            </remarks>
        </member>
        <member name="T:Llvm.NET.IExtensiblePropertyContainer">
            <summary>Interface to allow adding arbitrary named data items to an object</summary>
            <remarks>
            It is sometimes useful for code generation applications to attach some tool specific
            data to the LLVM objects created but that don't need representation as LLVM Metadata
            nodes. This interface provides such a facility.
            </remarks>
        </member>
        <member name="M:Llvm.NET.IExtensiblePropertyContainer.TryGetExtendedPropertyValue``1(System.String,``0@)">
            <summary>Try to get a value from the container</summary>
            <typeparam name="T">Type of value to retrieve</typeparam>
            <param name="id">id of the value to retrieve</param>
            <param name="value">value retrieved if present (or default value of type <typeparamref name="T"/> otherwise)</param>
            <returns>
            true if the item was found and it's type matches <typeparamref name="T"/> false otherwise.
            </returns>
        </member>
        <member name="M:Llvm.NET.IExtensiblePropertyContainer.AddExtendedPropertyValue(System.String,System.Object)">
            <summary>Adds a value to the container</summary>
            <param name="id">Id of the value</param>
            <param name="value">value to add</param>
            <remarks>
            Adds the value with the specified id. If a value with the same id
            already exists and its type is the same as <paramref name="value"/>
            it is replaced. If the existing value is of a different type, then
            an ArgumentException is thrown.
            </remarks>
        </member>
        <member name="T:Llvm.NET.InternalCodeGeneratorException">
            <summary>Exception generated when the internal state of the code generation cannot proceed due to an internal error</summary>
        </member>
        <member name="T:Llvm.NET.MemoryBuffer">
            <summary>LLVM MemoryBuffer</summary>
        </member>
        <member name="M:Llvm.NET.MemoryBuffer.#ctor(System.String)">
            <summary>Load a file as an LLVM Memory Buffer</summary>
            <param name="path">Path of the file to load into a <see cref="T:Llvm.NET.MemoryBuffer"/></param>
        </member>
        <member name="P:Llvm.NET.MemoryBuffer.Size">
            <summary>Size of the buffer</summary>
        </member>
        <member name="T:Llvm.NET.NativeModule">
            <summary>LLVM Bitcode module</summary>
            <remarks>
            A module is the basic unit for containing code in LLVM. Modules are an in memory
            representation of the LLVM bit-code.
            </remarks>
        </member>
        <member name="M:Llvm.NET.NativeModule.#ctor">
            <summary>Creates an unnamed module without debug information</summary>
        </member>
        <member name="M:Llvm.NET.NativeModule.#ctor(System.String)">
            <summary>Creates a new module with the specified id in a new context</summary>
            <param name="moduleId">Module's ID</param>
        </member>
        <member name="M:Llvm.NET.NativeModule.#ctor(System.String,Llvm.NET.Context)">
            <summary>Creates an named module in a given context</summary>
            <param name="moduleId">Module's ID</param>
            <param name="context">Context for the module</param>
        </member>
        <member name="M:Llvm.NET.NativeModule.#ctor(System.String,Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <summary>Creates a named module with a root <see cref="P:Llvm.NET.NativeModule.DICompileUnit"/> to contain debugging information</summary>
            <param name="moduleId">Module name</param>
            <param name="language">Language to store in the debugging information</param>
            <param name="srcFilePath">path of source file to set for the compilation unit</param>
            <param name="producer">Name of the application producing this module</param>
            <param name="optimized">Flag to indicate if the module is optimized</param>
            <param name="flags">Additional flags</param>
            <param name="runtimeVersion">Runtime version if any (use 0 if the runtime version has no meaning)</param>
        </member>
        <member name="M:Llvm.NET.NativeModule.#ctor(System.String,Llvm.NET.Context,Llvm.NET.DebugInfo.SourceLanguage,System.String,System.String,System.Boolean,System.String,System.UInt32)">
            <summary>Creates a named module with a root <see cref="P:Llvm.NET.NativeModule.DICompileUnit"/> to contain debugging information</summary>
            <param name="moduleId">Module name</param>
            <param name="context">Context for the module</param>
            <param name="language">Language to store in the debugging information</param>
            <param name="srcFilePath">path of source file to set for the compilation unit</param>
            <param name="producer">Name of the application producing this module</param>
            <param name="optimized">Flag to indicate if the module is optimized</param>
            <param name="compilationFlags">Additional flags</param>
            <param name="runtimeVersion">Runtime version if any (use 0 if the runtime version has no meaning)</param>
        </member>
        <member name="F:Llvm.NET.NativeModule.DebugVersionValue">
            <summary>Name of the Debug Version information module flag</summary>
        </member>
        <member name="F:Llvm.NET.NativeModule.DwarfVersionValue">
            <summary>Name of the Dwarf Version module flag</summary>
        </member>
        <member name="F:Llvm.NET.NativeModule.DebugMetadataVersion">
            <summary>Version of the Debug information Metadata</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.Comdats">
            <summary>Comdats for this module</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.Context">
            <summary><see cref="P:Llvm.NET.NativeModule.Context"/> this module belongs to</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.DIBuilder">
            <summary><see cref="T:Llvm.NET.DebugInfo.DebugInfoBuilder"/> to create debug information for this module</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.DICompileUnit">
            <summary>Debug Compile unit for this module</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.DataLayoutString">
            <summary>Data layout string</summary>
            <remarks>
            Note the data layout string doesn't do what seems obvious.
            That is, it doesn't force the target back-end to generate code
            or types with a particular layout. Rather, the layout string has
            to match the implicit layout of the target. Thus it should only
            come from the actual <see cref="T:Llvm.NET.TargetMachine"/> the code is
            targeting.
            </remarks>
        </member>
        <member name="P:Llvm.NET.NativeModule.Layout">
            <summary>Target data layout for this module</summary>
            <remarks>The layout is produced by parsing the <see cref="P:Llvm.NET.NativeModule.DataLayoutString"/>
            therefore this property changes anytime the <see cref="P:Llvm.NET.NativeModule.DataLayoutString"/> is
            set. Furthermore, setting this property will change the value of <see cref="P:Llvm.NET.NativeModule.DataLayoutString"/>.
            In other words, Layout and <see cref="P:Llvm.NET.NativeModule.DataLayoutString"/> are two different views
            of the same information.
            </remarks>
        </member>
        <member name="P:Llvm.NET.NativeModule.TargetTriple">
            <summary>Target Triple describing the target, ABI and OS</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.Globals">
            <summary>Globals contained by this module</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.Functions">
            <summary>Enumerable collection of functions contained in this module</summary>
        </member>
        <member name="P:Llvm.NET.NativeModule.Name">
            <summary>Name of the module</summary>
        </member>
        <member name="M:Llvm.NET.NativeModule.Optimize(Llvm.NET.TargetMachine)">
            <summary>Run optimization passes on the module</summary>
            <param name="targetMachine"><see cref="T:Llvm.NET.TargetMachine"/> for use during optimizations</param>
            <remarks>
            Options configuring optimization are provided by calling <see cref="M:Llvm.NET.StaticState.ParseCommandLineOptions(System.String[],System.String)"/>.
            The current implementation uses the legacy pass manager architecture, thus the options for controlling passes
            are the same as used for the LLVM 'opt' tool. Once LLVM stabilizes on the new pass manager support this
            will be obsoleted in favor of a new method that takes a string representation of the optimizations in a manner
            consistent with the support in the 'opt' tool.
            </remarks>
        </member>
        <member name="M:Llvm.NET.NativeModule.Verify(System.String@)">
            <summary>Verifies a bit-code module</summary>
            <param name="errmsg">Error messages describing any issues found in the bit-code</param>
            <returns>true if the verification succeeded and false if not.</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.GetFunction(System.String)">
            <summary>Gets a function by name from this module</summary>
            <param name="name">Name of the function to get</param>
            <returns>The function or null if not found</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddFunction(System.String,Llvm.NET.Types.IFunctionType)">
            <summary>Add a function with the specified signature to the module</summary>
            <param name="name">Name of the function to add</param>
            <param name="signature">Signature of the function</param>
            <returns><see cref="T:Llvm.NET.Values.Function"/>matching the specified signature and name</returns>
            <remarks>
            If a matching function already exists it is returned, and therefore the returned
            <see cref="T:Llvm.NET.Values.Function"/> may have a body and additional attributes. If a function of
            the same name exists with a different signature an exception is thrown as LLVM does
            not perform any function overloading.
            </remarks>
        </member>
        <member name="M:Llvm.NET.NativeModule.WriteToFile(System.String)">
            <summary>Writes a bit-code module to a file</summary>
            <param name="path">Path to write the bit-code into</param>
            <remarks>
            This is a blind write. (e.g. no verification is performed)
            So if an invalid module is saved it might not work with any
            later stage processing tools.
            </remarks>
        </member>
        <member name="M:Llvm.NET.NativeModule.WriteToTextFile(System.String,System.String@)">
            <summary>Writes this module as LLVM IR source to a file</summary>
            <param name="path">File to write the LLVM IR source to</param>
            <param name="errMsg">Error messages encountered, if any</param>
            <returns><see langword="true"/> if successful or <see langword="false"/> if not</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.WriteToString">
            <summary>Creates a string representation of the module</summary>
            <returns>LLVM textual representation of the module</returns>
            <remarks>
            This is intentionally NOT an override of ToString() as that is
            used by debuggers to show the value of a type and this can take
            an extremely long time (up to many seconds depending on complexity
            of the module) which is bad for the debugger.
            </remarks>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddAlias(Llvm.NET.Values.Value,System.String)">
            <summary>Add an alias to the module</summary>
            <param name="aliasee">Value being aliased</param>
            <param name="aliasName">Name of the alias</param>
            <returns><see cref="T:Llvm.NET.Values.GlobalAlias"/> for the alias</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.GetAlias(System.String)">
            <summary>Get an alias by name</summary>
            <param name="name">name of the alias to get</param>
            <returns>Alias matching <paramref name="name"/> or null if no such alias exists</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddGlobalInAddressSpace(System.UInt32,Llvm.NET.Types.ITypeRef,System.String)">
            <summary>Adds a global to this module with a specific address space</summary>
            <param name="addressSpace"></param>
            <param name="typeRef">Type of the global's value</param>
            <param name="name">Name of the global</param>
            <returns>The new <see cref="T:Llvm.NET.Values.GlobalVariable"/></returns>
            <openissues>
            - What does LLVM do if creating a second Global with the same name (return null, throw, crash??,...)
            </openissues>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddGlobalInAddressSpace(System.UInt32,Llvm.NET.Types.ITypeRef,System.Boolean,Llvm.NET.Linkage,Llvm.NET.Values.Constant)">
            <summary>Adds a global to this module</summary>
            <param name="addressSpace"></param>
            <param name="typeRef">Type of the global's value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddGlobalInAddressSpace(System.UInt32,Llvm.NET.Types.ITypeRef,System.Boolean,Llvm.NET.Linkage,Llvm.NET.Values.Constant,System.String)">
            <summary>Adds a global to this module</summary>
            <param name="addressSpace"></param>
            <param name="typeRef">Type of the global's value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <param name="name">Name of the variable</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddGlobal(Llvm.NET.Types.ITypeRef,System.String)">
            <summary>Adds a global to this module</summary>
            <param name="typeRef">Type of the global's value</param>
            <param name="name">Name of the global</param>
            <returns>The new <see cref="T:Llvm.NET.Values.GlobalVariable"/></returns>
            <openissues>
            - What does LLVM do if creating a second Global with the same name (return null, throw, crash??,...)
            </openissues>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddGlobal(Llvm.NET.Types.ITypeRef,System.Boolean,Llvm.NET.Linkage,Llvm.NET.Values.Constant)">
            <summary>Adds a global to this module</summary>
            <param name="typeRef">Type of the global's value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddGlobal(Llvm.NET.Types.ITypeRef,System.Boolean,Llvm.NET.Linkage,Llvm.NET.Values.Constant,System.String)">
            <summary>Adds a global to this module</summary>
            <param name="typeRef">Type of the global's value</param>
            <param name="isConst">Flag to indicate if this global is a constant</param>
            <param name="linkage">Linkage type for this global</param>
            <param name="constVal">Initial value for the global</param>
            <param name="name">Name of the variable</param>
            <returns>New global variable</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.GetTypeByName(System.String)">
            <summary>Retrieves a <see cref="T:Llvm.NET.Types.ITypeRef"/> by name from the module</summary>
            <param name="name">Name of the type</param>
            <returns>The type or null if no type with the specified name exists in the module</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.GetNamedGlobal(System.String)">
            <summary>Retrieves a named global from the module</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddModuleFlag(Llvm.NET.ModuleFlagBehavior,System.String,System.UInt32)">
            <summary>Adds a module flag to the module</summary>
            <param name="behavior">Module flag behavior for this flag</param>
            <param name="name">Name of the flag</param>
            <param name="value">Value of the flag</param>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddModuleFlag(Llvm.NET.ModuleFlagBehavior,System.String,Llvm.NET.LlvmMetadata)">
            <summary>Adds a module flag to the module</summary>
            <param name="behavior">Module flag behavior for this flag</param>
            <param name="name">Name of the flag</param>
            <param name="value">Value of the flag</param>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddNamedMetadataOperand(System.String,Llvm.NET.LlvmMetadata)">
            <summary>Adds operand value to named metadata</summary>
            <param name="name">Name of the metadata</param>
            <param name="value">operand value</param>
        </member>
        <member name="M:Llvm.NET.NativeModule.AddVersionIdentMetadata(System.String)">
            <summary>Adds an llvm.ident metadata string to the module</summary>
            <param name="version">version information to place in the llvm.ident metadata</param>
        </member>
        <member name="M:Llvm.NET.NativeModule.CreateMDNode(System.String)">
            <summary>Create an <see cref="T:Llvm.NET.MDNode"/> from a string</summary>
            <param name="value">String value</param>
            <returns>New node with the string as <see cref="P:Llvm.NET.MDNode.Operands"/>[0] (as an MDString)</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.CreateFunction(Llvm.NET.DebugInfo.DIScope,System.String,System.String,Llvm.NET.DebugInfo.DIFile,System.UInt32,Llvm.NET.DebugInfo.DebugFunctionType,System.Boolean,System.Boolean,System.UInt32,Llvm.NET.DebugInfo.DebugInfoFlags,System.Boolean,Llvm.NET.MDNode,Llvm.NET.MDNode)">
            <summary>Creates a Function definition with Debug information</summary>
            <param name="scope">Containing scope for the function</param>
            <param name="name">Name of the function in source language form</param>
            <param name="linkageName">Mangled linker visible name of the function (may be same as <paramref name="name"/> if mangling not required by source language</param>
            <param name="file">File containing the function definition</param>
            <param name="line">Line number of the function definition</param>
            <param name="signature">LLVM Function type for the signature of the function</param>
            <param name="isLocalToUnit">Flag to indicate if this function is local to the compilation unit</param>
            <param name="isDefinition">Flag to indicate if this is a definition</param>
            <param name="scopeLine">First line of the function's outermost scope, this may not be the same as the first line of the function definition due to source formatting</param>
            <param name="debugFlags">Additional flags describing this function</param>
            <param name="isOptimized">Flag to indicate if this function is optimized</param>
            <param name="tParam"></param>
            <param name="decl"></param>
            <returns>Function described by the arguments</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.Clone">
            <summary>Clones the current module</summary>
            <returns>Cloned module</returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.Llvm#NET#IExtensiblePropertyContainer#TryGetExtendedPropertyValue``1(System.String,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Llvm.NET.NativeModule.Llvm#NET#IExtensiblePropertyContainer#AddExtendedPropertyValue(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Llvm.NET.NativeModule.LoadFrom(System.String,Llvm.NET.Context)">
            <summary>Load a bit-code module from a given file</summary>
            <param name="path">path of the file to load</param>
            <param name="context">Context to use for creating the module</param>
            <returns>Loaded <see cref="T:Llvm.NET.NativeModule"/></returns>
        </member>
        <member name="M:Llvm.NET.NativeModule.LoadFrom(Llvm.NET.MemoryBuffer,Llvm.NET.Context)">
            <summary>Load bit code from a memory buffer</summary>
            <param name="buffer">Buffer to load from</param>
            <param name="context">Context to load the module into</param>
            <returns>Loaded <see cref="T:Llvm.NET.NativeModule"/></returns>
            <remarks>
            This along with <see cref="M:Llvm.NET.NativeModule.WriteToBuffer"/> are useful for "cloning"
            a module from one context to another. This allows creation of multiple
            modules on different threads and contexts and later moving them to a
            single context in order to link them into a single final module for
            optimization.
            </remarks>
        </member>
        <member name="T:Llvm.NET.PassManagerBuilder">
            <summary>Provides a wrapper around the LLVM PassManagerBuilder</summary>
            <remarks>This class is still in the experimental stage as there is a lack of full support from the C API</remarks>
        </member>
        <member name="T:Llvm.NET.TargetRegistrations">
            <summary>Target tools to register/enable</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.None">
            <summary>Register nothing</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.Target">
            <summary>Register the Target class</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.TargetInfo">
            <summary>Register the Target info for the target</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.TargetMachine">
            <summary>Register the target machine(s) for a target</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.AsmPrinter">
            <summary>Registers the assembly source code generator for a target</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.Disassembler">
            <summary>Registers the Disassembler for a target</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.AsmParser">
            <summary>Registers the assembly source parser for a target</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.CodeGen">
            <summary>Registers all the code generation components</summary>
        </member>
        <member name="F:Llvm.NET.TargetRegistrations.All">
            <summary>Registers all components</summary>
        </member>
        <member name="T:Llvm.NET.StaticState">
            <summary>Provides support for various LLVM static state initialization and manipulation</summary>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterAll(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for all available targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterNative(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for the target representing the system the calling process is running on</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterAArch64(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for ARM AArch64 target(s)</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterARM(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for ARM 32bit and 16bit thumb targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterHexagon(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for the Hexagon CPU</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterMips(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for MIPS targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterMSP430(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for MSP430 targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterNVPTX(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for the NVPTX targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterPowerPC(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for the PowerPC targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterAMDGPU(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for AMDGPU targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterSparc(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for SPARC targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterSystemZ(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for SystemZ targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterX86(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for X86 targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="M:Llvm.NET.StaticState.RegisterXCore(Llvm.NET.TargetRegistrations)">
            <summary>Registers components for XCore targets</summary>
            <param name="registrations">Flags indicating which components to register/enable</param>
        </member>
        <member name="T:Llvm.NET.Target">
            <summary>LLVM Target Instruction Set Architecture</summary>
        </member>
        <member name="P:Llvm.NET.Target.Name">
            <summary>Name of this target</summary>
        </member>
        <member name="P:Llvm.NET.Target.Description">
            <summary>Description of this target</summary>
        </member>
        <member name="P:Llvm.NET.Target.HasJIT">
            <summary>Flag indicating if this target has JIT support</summary>
        </member>
        <member name="P:Llvm.NET.Target.HasTargetMachine">
            <summary>Flag indicating if this target has a TargetMachine initialized</summary>
        </member>
        <member name="P:Llvm.NET.Target.HasAsmBackEnd">
            <summary>Flag indicating if this target has an Assembly code generating back end initialized</summary>
        </member>
        <member name="M:Llvm.NET.Target.CreateTargetMachine(Llvm.NET.Context,System.String,System.String,System.String,Llvm.NET.CodeGenOpt,Llvm.NET.Reloc,Llvm.NET.CodeModel)">
            <summary>Creates a <see cref="T:Llvm.NET.TargetMachine"/> for the target and specified parameters</summary>
            <param name="context">Context to use for LLVM objects created by this machine</param>
            <param name="triple">Target triple for this machine (e.g. -mtriple)</param>
            <param name="cpu">CPU for this machine (e.g. -mcpu)</param>
            <param name="features">Features for this machine (e.g. -mattr...)</param>
            <param name="optLevel">Optimization level</param>
            <param name="relocationMode">Relocation mode for generated code</param>
            <param name="codeModel"><see cref="T:Llvm.NET.CodeModel"/> to use for generated code</param>
            <returns><see cref="T:Llvm.NET.TargetMachine"/> based on the specified parameters</returns>
        </member>
        <member name="P:Llvm.NET.Target.AvailableTargets">
            <summary>Retrieves an enumerable collection of the available targets built into this library</summary>
        </member>
        <member name="M:Llvm.NET.Target.FromTriple(System.String)">
            <summary>Gets the target for a given target "triple" value</summary>
            <param name="targetTriple">Target triple string describing the target</param>
            <returns>Target for the given triple</returns>
        </member>
        <member name="T:Llvm.NET.TargetMachine">
            <summary>Target specific code generation information</summary>
        </member>
        <member name="P:Llvm.NET.TargetMachine.Target">
            <summary>Retrieves the Target that owns this <see cref="T:Llvm.NET.TargetMachine"/></summary>
        </member>
        <member name="P:Llvm.NET.TargetMachine.Triple">
            <summary>Target triple describing this machine</summary>
        </member>
        <member name="P:Llvm.NET.TargetMachine.Cpu">
            <summary>CPU Type for this machine</summary>
        </member>
        <member name="P:Llvm.NET.TargetMachine.Features">
            <summary>CPU specific features for this machine</summary>
        </member>
        <member name="P:Llvm.NET.TargetMachine.TargetData">
            <summary>Gets Layout information for this machine</summary>
        </member>
        <member name="M:Llvm.NET.TargetMachine.EmitToFile(Llvm.NET.NativeModule,System.String,Llvm.NET.CodeGenFileType)">
            <summary>Generate code for the target machine from a module</summary>
            <param name="module"><see cref="T:Llvm.NET.NativeModule"/> to generate the code from</param>
            <param name="path">Path to the output file</param>
            <param name="fileType">Type of file to emit</param>
        </member>
        <member name="P:Llvm.NET.TargetMachine.Context">
            <summary><see cref="P:Llvm.NET.TargetMachine.Context"/>This machine is associated with</summary>
        </member>
        <member name="T:Llvm.NET.DataLayout">
            <summary>Provides access to LLVM target data layout information</summary>
            <remarks>
            <para>There is a distinction between various sizes and alignment for a given type
            that are target dependent.</para>
            <para>The following table illustrates the differences in sizes and their meaning
             for a sample set of types.</para>
            <list type="table">
              <listheader>
              <term>Type</term>
              <term>SizeInBits</term>
              <term>StoreSizeInBits</term>
              <term>AllocSizeInBits</term>
              </listheader>
              <item><term>i1</term>         <term>1</term>   <term>8</term>   <term>8</term></item>
              <item><term>i8</term>         <term>8</term>   <term>8</term>   <term>8</term></item>
              <item><term>i19</term>        <term>19</term>  <term>24</term>  <term>32</term></item>
              <item><term>i32</term>        <term>32</term>  <term>32</term>  <term>32</term></item>
              <item><term>i100</term>       <term>100</term> <term>104</term> <term>128</term></item>
              <item><term>i128</term>       <term>128</term> <term>128</term> <term>128</term></item>
              <item><term>Float</term>      <term>32</term>  <term>32</term>  <term>32</term></item>
              <item><term>Double</term>     <term>64</term>  <term>64</term>  <term>64</term></item>
              <item><term>X86_FP80</term>   <term>80</term>  <term>80</term>  <term>96</term></item>
            </list>
            <note type="note">
            The alloc size depends on the alignment, and thus on the target.
            The values in the example table are for x86-32-linux.
            </note>
            </remarks>
        </member>
        <member name="P:Llvm.NET.DataLayout.Context">
            <summary>Context used for this data (in particular, for retrieving pointer types)</summary>
        </member>
        <member name="P:Llvm.NET.DataLayout.Endianess">
            <summary>Retrieves the byte ordering for this target</summary>
        </member>
        <member name="M:Llvm.NET.DataLayout.PointerSize">
            <summary>Retrieves the size of a pointer for the default address space of the target</summary>
            <returns>Size of a pointer to the default address space</returns>
        </member>
        <member name="M:Llvm.NET.DataLayout.PointerSize(System.UInt32)">
            <summary>Retrieves the size of a pointer for a given address space of the target</summary>
            <param name="addressSpace">Address space for the pointer</param>
            <returns>Size of a pointer</returns>
        </member>
        <member name="M:Llvm.NET.DataLayout.IntPtrType">
            <summary>Retrieves an LLVM integer type with the same bit width as
            a pointer for the default address space of the target</summary>
            <returns>Integer type matching the bit width of a native pointer in the target's default address space</returns>
        </member>
        <member name="M:Llvm.NET.DataLayout.IntPtrType(System.UInt32)">
            <summary>Retrieves an LLVM integer type with the same bit width as
            a pointer for the given address space of the target</summary>
            <returns>Integer type matching the bit width of a native pointer in the target's address space</returns>
        </member>
        <member name="M:Llvm.NET.DataLayout.BitSizeOf(Llvm.NET.Types.ITypeRef)">
            <summary>Returns the number of bits necessary to hold the specified type.</summary>
            <param name="typeRef">Type to retrieve the size of</param>
            <remarks>
            <para>This method determines the bit size of a type (e.g. the minimum number of
            bits required to represent any value of the given type.) This is distinct from the storage
            and stack size due to various target alignment requirements.</para>
            </remarks>
        </member>
        <member name="M:Llvm.NET.DataLayout.StoreSizeOf(Llvm.NET.Types.ITypeRef)">
            <summary>Retrieves the number of bits required to store a value of the given type</summary>
            <param name="typeRef">Type to retrieve the storage size of</param>
            <returns>Number of bits required to store a value of the given type in the target</returns>
            <remarks>This method retrieves the storage size in bits of a given type. The storage size
            includes any trailing padding bits that may be needed if the target requires reading a wider
            word size. (e.g. most systems can't write a single bit value for an LLVM i1, thus the
            storage size is whatever the minimum number of bits that the target requires to store a value
            of the given type)
            </remarks>
        </member>
        <member name="M:Llvm.NET.DataLayout.AbiSizeOf(Llvm.NET.Types.ITypeRef)">
            <summary>Retrieves the ABI specified size of the given type</summary>
            <param name="typeRef">Type to get the size from</param>
            <returns>Size of the type</returns>
        </member>
        <member name="M:Llvm.NET.DataLayout.AbiAlignmentOf(Llvm.NET.Types.ITypeRef)">
            <summary>Retrieves the ABI specified alignment, in bytes, for a specified type</summary>
            <param name="typeRef">Type to get the alignment for</param>
            <returns>ABI specified alignment</returns>
        </member>
        <member name="M:Llvm.NET.DataLayout.CallFrameAlignmentOf(Llvm.NET.Types.ITypeRef)">
            <summary>Retrieves the call frame alignment for a given type</summary>
            <param name="typeRef">type to get the alignment of</param>
            <returns>Alignment for the type</returns>
        </member>
        <member name="M:Llvm.NET.DataLayout.Parse(Llvm.NET.Context,System.String)">
            <summary>Parses an LLVM target layout string</summary>
            <param name="context"><see cref="P:Llvm.NET.DataLayout.Context"/> for types created by the new <see cref="T:Llvm.NET.DataLayout"/></param>
            <param name="layout">string to parse</param>
            <returns>Parsed target data</returns>
            <remarks>For full details on the syntax of the string see <a href="http://llvm.org/releases/3.9.1/docs/LangRef.html#data-layout">http://llvm.org/releases/3.9.1/docs/LangRef.html#data-layout</a></remarks>
        </member>
    </members>
</doc>
