#Requires -Version 5.0

<#
.SYNOPSIS
    Wraps CMake Visual Studio solution generation and build for LLVM as used by the LLVM.NET project

.DESCRIPTION
    This script is used to build LLVM libraries for Windows and bundle the results into a NUGET package.
    A NUGET package is immediately consumable by projects without requiring a complete build of the LLVM
    source code. This is particularly useful for OSS projects that leverage public build services like
    Jenkins or AppVeyor, etc... Public build services often limit the time a build can run so building
    all of the LLVM libraries for multiple platforms can be problematic as the LLVM builds take quite
    a while on their own. Furthermore public services often limit the size of each NuGet pacakge to some
    level (Nuget.org tops out at 250MB). So the Nuget Packaging supports splitting out the libraries,
    headers and symbols into smaller packages with a top level "MetaPackage" that lists all the others
    as dependencies. The complete set of packages is:
       - Llvm.Libs.<Version>.nupkg
       - Llvm.Libs.core.pdbs.x64-Debug.<Version>.nupkg
       - Llvm.Libs.core.pdbs.x86-Debug.<Version>.nupkg
       - Llvm.Libs.core.x64-Debug.<Version>.nupkg
       - Llvm.Libs.core.x64-Release.<Version>.nupkg
       - Llvm.Libs.core.x86-Debug.<Version>.nupkg
       - Llvm.Libs.core.x86-Release.<Version>.nupkg
       - Llvm.Libs.targets.x64-Debug.<Version>.nupkg
       - Llvm.Libs.targets.x64-Release.<Version>.nupkg
       - Llvm.Libs.targets.x86-Debug.<Version>.nupkg
       - Llvm.Libs.targets.x86-Release.<Version>.nupkg

.PARAMETER LlvmVersion
    Specifies the LLVM Version, which is used in registering the location of the lib and headers in the registry. The default value is the currently
    supported version of LLVM. However, when working to support a new release of LLVM it is useful to force a different version number.

.PARAMETER LlvmRoot
    This specifies the root of the LLVM source tree to build.

.PARAMETER BuildOutputPath
    The path to where the projects are generated and the binaries they build will be located.

.PARAMETER Generate
    Switch to run CMAKE configuration and project/solution generation

.PARAMETER Build
    Switch to enable building the projects generated by the -Generate option

.PARAMETER BaseVsGenerator
    This specifies the base name of the CMAKE Visual Studio Generator. This script will add the "Win64" part of the name when generating 64bit projects.
    The default value is for Visual Studio 2017 as LLVM.NET is migrating to Full VS 2017 support.

.PARAMETER CreateSettingsJson
    This flag generates the Visual Studio CMakeSettings.json file with the CMAKE settings for LLVM using. This allows opening the source folder in
    Visual C++ tools for CMake in Visual Studio 2017.

.PARAMETER Pack
    Set this flag to generate the Nuget packages for the libraries and headers

.PARAMETER PackStyle
    Defines the kind of package to generate can be one of "SinglePack" or "MultiPack". Multipack packaging creates multiple packages to work better
    with push to public galleries. SinglePack is simpler but at a size of just under 1GB is usually too big to upload to public servers. So, the
    multipack creates a "MetaPackage" with the common headers and a set of dependent packages, one for each platform configuration combination. These,
    smaller(ish) packages are more readily uploaded to public servers. Consumers should only reference the meta-package.
#>
[CmdletBinding()]
param( [Parameter(Mandatory=$true, ParameterSetName="common")]
       [Parameter(Mandatory=$true, ParameterSetName="pack")]
       [string]
       $BuildOutputPath,

       [Parameter(ParameterSetName="common")]
       [Parameter(ParameterSetName="pack")]
       [switch]
       $Generate=$true,

       [Parameter(ParameterSetName="common")]
       [Parameter(ParameterSetName="pack")]
       [switch]
       $Build=$true,

       [Parameter(ParameterSetName="common")]
       [Parameter(ParameterSetName="pack")]
       [switch]
       $CreateSettingsJson=$true,

       [Parameter(ParameterSetName="common")]
       [Parameter(ParameterSetName="pack")]
       [ValidateNotNullOrEmpty()]
       [string]
       $LlvmVersion="4.0.1",

       [Parameter(Mandatory=$true,ParameterSetName="common")]
       [Parameter(Mandatory=$true,ParameterSetName="pack")]
       [ValidateNotNullOrEmpty()]
       [string]$LlvmRoot,

       [Parameter(ParameterSetName="common")]
       [Parameter(ParameterSetName="pack")]
       [ValidateNotNullOrEmpty()]
       [string]
       $BaseVsGenerator="Visual Studio 15 2017",

       [Parameter(ParameterSetName="pack")]
       [switch]$Pack,

       [Parameter(ParameterSetName="pack")]
       [ValidateSet("SinglePack", "MultiPack")]
       [string]$PackStyle="SinglePack"
     )

. .\CmakeHelpers.ps1

$scriptRoot = $PSScriptRoot

function Normalize-Path([string]$path )
{
    $path = [System.IO.Path]::Combine((pwd).Path,$path)
    return [System.IO.Path]::GetFullPath($path)
}

function New-LlvmCmakeConfig([string]$platform, [string]$config, [string]$BaseGenerator, [string]$baseBuild, [string]$srcRoot )
{
    [CMakeConfig]$cmakeConfig = New-Object CMakeConfig -ArgumentList $platform, $config, $BaseGenerator, $baseBuild, $srcRoot
    $cmakeConfig.CMakeBuildVariables = @{
        LLVM_ENABLE_RTTI = "ON"
        LLVM_BUILD_TOOLS = "OFF"
        LLVM_BUILD_TESTS = "OFF"
        LLVM_BUILD_EXAMPLES = "OFF"
        LLVM_BUILD_DOCS = "OFF"
        LLVM_BUILD_RUNTIME = "OFF"
        LLVM_TARGETS_TO_BUILD  = "all"
        CMAKE_INSTALL_PREFIX = "Install"
        CMAKE_CONFIGURATION_TYPES = $config
    }

    return $cmakeConfig
}

function MakePropList([hashtable]$hashTable)
{
    return ( $hashTable.GetEnumerator() | %{ @{$true=$_.Key;$false= $_.Key + "=" + $_.Value }[[string]::IsNullOrEmpty($_.Value) ] } ) -join ';'
}

function BuildPlatformConfigPackages($srcRoot, $buildOut, $version)
{
    foreach( $platform in ("x86","x64"))
    {
        foreach( $config in ("Debug","Release"))
        {
            Write-Information "Generating Llvm.Libs.$platform-$config.nupkg"
            $properties = MakePropList @{
                            llvmsrcroot=$srcRoot
                            llvmbuildroot=$buildOut;
                            version=$version;
                            platform=$platform;
                            configuration=$config
                          }
            nuget pack Llvm.Libs.core.Platform-Configuration.nuspec -properties $properties
            if( $config -ieq "Debug")
            {
                nuget pack Llvm.Libs.core.pdbs.Platform-Configuration.nuspec -properties $properties
            }
            
            # generate nuspec for each target arch, platform, config from the template
            $nuspec = [xml](Get-Content Llvm.Libs.targets.nuspec.template)
            $nuspecNamespace = 'http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd'
            $ns = @{nuspec=$nuspecNamespace}
            $architectures = ("AArch64","AMDGPU","ARM","BPF","Hexagon","Lanai","Mips","MSP430","NVPTX","PowerPC","RISCV","Sparc","SystemZ","X86","XCore")
            $files = $nuspec | Select-Xml "//nuspec:files" -Namespace $ns
            foreach( $arch in $architectures)
            {
                foreach( $item in (Get-ChildItem -Path (join-path $buildOut "$platform-$config\$config\lib") -Filter "Llvm$arch*"))
                {
                    $fileElement = $nuspec.CreateElement("file",$nuspecNamespace);
                    $srcAttrib = $nuspec.CreateAttribute("src")
                    $srcAttrib.InnerText = "`$llvmbuildroot`$\`$platform`$-`$configuration`$\`$configuration`$\lib\$($item.Name)"
                    $targetAttrib = $nuspec.CreateAttribute("target")
                    $targetAttrib.InnerText = 'lib\native\lib'
                    $fileElement.Attributes.Append( $srcAttrib )  | Out-Null
                    $fileElement.Attributes.Append( $targetAttrib )  | Out-Null
                    $files.Node.AppendChild( $fileElement )  | Out-Null
                }
            }

            # generate nuget package from the generate nuspec
            $generatedNuSpec = "Llvm.Libs.targets.$platform-$config.nuspec"
            $nuspec.Save($generatedNuSpec) | Out-Null
            nuget pack $generatedNuSpec -properties $properties
        }
    }
}

function GenerateMultiPack($version, $srcRoot, $buildOutput)
{
    #update system search path to include the directory of this script for nuget.exe
    $oldPath = $env:Path
    $env:Path = "$scriptRoot;$env:Path"
    try
    {
        $nugetPaths = where.exe nuget.exe 2>$null
        if( !$nugetPaths )
        {
            # Download it from official nuget release location
            Invoke-WebRequest -UseBasicParsing -Uri https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile nuget.exe
        }

        BuildPlatformConfigPackages $srcRoot $buildOutput $version
        Write-Information "Generating meta-package"
        $properties = MakePropList @{
                        llvmsrcroot=$srcRoot
                        llvmbuildroot=$buildOutput;
                        version=$version
                        }

        nuget pack .\Llvm.Libs.MetaPackage.nuspec -Properties $properties
    }
    finally
    {
        $env:Path = $oldPath
    }
}

function GenerateSinglePack($version, $srcRoot, $buildOutput)
{
    #update system search path to include the directory of this script for nuget.exe
    $oldPath = $env:Path
    $env:Path = "$scriptRoot;$env:Path"
    try
    {
        $nugetPaths = where.exe nuget.exe 2>$null
        if( !$nugetPaths )
        {
            # Download it from official nuget release location
            Invoke-WebRequest -UseBasicParsing -Uri https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile nuget.exe
        }

        Write-Information "Generating single-package"
        $properties = MakePropList @{
                        llvmsrcroot=$srcRoot
                        llvmbuildroot=$buildOutput;
                        version=$version
                        }
        nuget pack .\Llvm.Libs.SinglePackage.nuspec -Properties $properties
    }
    finally
    {
        $env:Path = $oldPath
    }
}

#--- Main Script Body

# Force absolute paths for input params dealing in paths
$LlvmRoot = Normalize-Path $LlvmRoot
$BuildOutputPath = Normalize-Path $BuildOutputPath

# Construct array of configurations to deal with
$configurations = @( (New-LlvmCmakeConfig x86 "Release" $BaseVsGenerator $BuildOutputPath $LlvmRoot),
                     (New-LlvmCmakeConfig x86 "Debug" $BaseVsGenerator $BuildOutputPath $LlvmRoot),
                     (New-LlvmCmakeConfig x64 "Release" $BaseVsGenerator $BuildOutputPath $LlvmRoot),
                     (New-LlvmCmakeConfig x64 "Debug" $BaseVsGenerator $BuildOutputPath $LlvmRoot)
                  )

Write-Information "LLVM Source Root: $LlvmRoot"
$cmakeListPath = Join-Path $LlvmRoot CMakeLists.txt
if( !( Test-Path -PathType Leaf $cmakeListPath ) )
{
    throw "'$cmakeListPath' is missing, the current directory does not appear to be a valid source directory"
}

$timer = [System.Diagnostics.Stopwatch]::StartNew()

if( $CreateSettingsJson )
{
    New-CmakeSettings $configurations | Out-File (join-path $LlvmRoot CMakeSettings.json)
}

if( $Generate )
{
    try
    {
        foreach( $config in $configurations )
        {
            Generate-CMake $config $LlvmRoot
        }
    }
    finally
    {
        Write-Information ("Total Generation Time: {0}" -f($timer.Elapsed.ToString()))
    }
}

if( $Build )
{
    $buildTimer = [System.Diagnostics.Stopwatch]::StartNew()
    try
    {
        foreach( $config in $configurations )
        {
            Build-Cmake $config
        }
    }
    finally
    {
        $buildTimer.Stop()
        Write-Information ("Total Build Time: {0}" -f($buildTimer.Elapsed.ToString()))
    }
}

if( $PsCmdlet.ParameterSetName -eq "pack" )
{
    if( $PackStyle -ieq "MultiPack" )
    {
        GenerateMultiPack $LlvmVersion $LlvmRoot $BuildOutputPath
    }
    else
    {
        GenerateSinglePack $LlvmVersion $LlvmRoot $BuildOutputPath
    }
}

$timer.Stop()
Write-Information ("Total Time: {0}" -f($timer.Elapsed.ToString()))
